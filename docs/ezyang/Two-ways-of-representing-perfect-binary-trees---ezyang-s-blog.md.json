["```\n{-# LANGUAGE ScopedTypeVariables, GADTs, ImpredicativeTypes #-}\n\n```", "```\ndata Z\ndata S n\n\ndata L i a where\n    L :: a -> L Z a\n    N :: L i a -> L i a -> L (S i) a\n\n```", "```\nexampleL = N (N (L 1) (L 2)) (N (L 3) (L 4))\n\ntoListL :: L i a -> [a] -- type signature is necessary!\ntoListL (L x) = [x]\ntoListL (N l r) = toListL l ++ toListL r\n\n```", "```\ndata L' a = forall i. L' { unL' :: L i a }\ndata Ex a = forall i. Ex [L i a]\n\nfromListL :: [a] -> L' a\nfromListL xs = g (Ex (map L xs))\n  where\n    g (Ex [x]) = L' x\n    g (Ex xs)  = g (Ex (f xs))\n    f (x:y:xs) = (N x y) : f xs\n    f _ = []\n\n```", "```\ndata B a = Two (B (a, a)) | One a\n    deriving Show\n\n```", "```\nexampleB = Two (Two (One ((1,2), (3,4))))\n\nfromListB :: [a] -> B a\nfromListB [x] = One x\nfromListB xs = Two (fromListB (pairs xs))\n    where pairs (x:y:xs) = (x,y) : pairs xs\n          pairs _ = []\n\ntoListB :: B a -> [a]\ntoListB (One x) = [x]\ntoListB (Two c) = concatMap (\\(x,y) -> [x,y]) (toListB c)\n\n```", "```\ncataL :: (t a -> t a -> t a, a -> t a) -> L i a -> t a\ncataL (n,z) (N l r) = n (cataL (n,z) l) (cataL (n,z) r)\ncataL (n,z) (L x) = z x\n\n```", "```\ncataB :: (forall a. a -> t a, forall a. t (a, a) -> t a) -> B a -> t a\ncataB (f,g) (One a) = f a\ncataB (f,g) (Two t) = g (cataB (f,g) t)\n\n```", "```\ncataLB :: forall t a. (t a -> t a -> t a, a -> t a) -> B a -> t a\ncataLB (n,z) t = f t z\n  where\n    f :: forall b. B b -> (b -> t a) -> t a\n    f (One a) z = z a\n    f (Two t) z = f t (\\(l,r) -> n (z l) (z r))\n\n```"]