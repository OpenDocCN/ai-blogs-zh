["```\nmodule GHC.RTS.Stats where\n\n-- Info is not collected unless you run with certain RTS options.  If\n-- you are planning on using this on a long-running server, costs of the\n-- options would be good to have (we also probably need to add extra\n-- options which record, but have no outwardly visible effect.)\n\n-- Read out static parameters that were provided via +RTS\n\ngenerations :: IO Int\n\n---------------------------------------------------------------------\n-- Full statistics\n\n-- Many stats are internally collected as words. Should be publish\n-- words?\n\n-- Names off of machine readable formats\n\nbytesAllocated :: IO Int64\nnumGCs :: IO Int64\nnumByteUsageSamples :: IO Int64\naverageBytesUsed :: IO Int64 -- cumulativeBytesUsed / numByteUsageSamples\nmaxBytesUsed :: IO Int64\n-- peakMemoryBlocksAllocated :: IO Int64\npeakMegabytesAllocated :: IO Int64\ninitCpuSeconds :: IO Double\ninitWallSeconds :: IO Double\nmutatorCpuSeconds :: IO Double\nmutatorWallSeconds :: IO Double\ngcCpuSeconds :: IO Double\ngcWallSeconds :: IO Double\n\n-- Wouldn't be too unreasonable to offer a data structure with all of\n-- this?  Unclear.  At least, it would prevent related data from\n-- desynchronizing.\n\ndata GlobalStats = GlobalStats\n    { g_bytes_allocated :: Int64\n    , g_num_GCs :: Int64\n    , g_num_byte_usage_samples :: Int64\n    , g_average_bytes_used :: Int64\n    , g_max_bytes_used :: Int64\n    , g_peak_megabytes_allocated :: Int64\n    , g_init_cpu_seconds :: Double\n    , g_init_wall_seconds :: Double\n    , g_mutator_cpu_seconds :: Double\n    , g_mutator_wall_seconds :: Double\n    , g_gc_cpu_seconds :: Double\n    , g_gc_wall_seconds :: Double\n    }\nglobalStats :: IO GlobalStats\ngenerationStats :: Int -> IO GlobalStats\n\n---------------------------------------------------------------------\n-- GC statistics\n\n-- We can't offer a realtime stream of GC events, because they come\n-- to fast. (Test? eventlog comes to fast, maybe GC is manageable,\n-- but you don't want to trigger GC in your handler.)\n\ndata GCStats = GCStats\n    { gc_alloc :: Int64\n    , gc_live :: Int64\n    , gc_copied :: Int64\n    , gc_gen :: Int\n    , gc_max_copied :: Int64\n    , gc_avg_copied :: Int64\n    , gc_slop :: Int64\n    , gc_wall_seconds :: Int64\n    , gc_cpu_seconds :: Int64\n    , gc_faults :: Int\n    }\nlastGC :: IO GCStats\nlastMajorGC :: IO GCStats\nallocationRate :: IO Double\n\n---------------------------------------------------------------------\n-- Parallel GC statistics\n\ndata ParGCStats = ParGCStats\n    { par_avg_copied :: Int64\n    , par_max_copied :: Int64\n    }\nparGCStats :: IO ParGCStats\nparGCNodes :: IO Int64\n\n---------------------------------------------------------------------\n-- Threaded runtime statistics\ndata TaskStats = TaskStats\n    -- Inconsistent naming convention here: mut_time or mut_cpu_seconds?\n    -- mut_etime or mut_wall_seconds? Hmm...\n    { task_mut_time :: Int64\n    , task_mut_etime :: Int64\n    , task_gc_time :: Int64\n    , task_gc_etime :: Int64\n    }\n\n---------------------------------------------------------------------\n-- Spark statistics\n\ndata SparkStats = SparkStats\n    { s_created :: Int64\n    , s_dud :: Int64\n    , s_overflowed :: Int64\n    , s_converted :: Int64\n    , s_gcd :: Int64\n    , s_fizzled :: Int64\n    }\nsparkStats :: IO SparkStats\nsparkStatsCapability :: Int -> IO SparkStats\n\n```"]