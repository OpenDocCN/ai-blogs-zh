["```\ndata SpineStrictList a = Nil | Cons a !(SpineStrictList a)\nssFromList [] l = l\nssFromList (x:xs) l = ssFromList xs (Cons x l)\nssMap _ Nil l = l\nssMap f (Cons x xs) l = ssMap f xs (Cons (f x) l)\n\nmain = do\n    let l = ssFromList ([1..1000000] :: [Int]) Nil\n        f x = ssMap permute x Nil\n    evaluate (f (f (f (f (f (f (f (f l))))))))\n\npermute y = y * 2 + 1\n\n```", "```\npermute !y = y * 2 + 1\n\n```", "```\nssMap' _ Nil l = l\nssMap' f (Cons x xs) l = ssMap' f xs ((Cons $! f x) l)\n\n```", "```\ndata StrictList a = Nil | Cons !a !(SpineStrictList a)\n\n```", "```\ndata Lazy a = Lazy a\ntype SpineStrictList a = StrictList (Lazy a)\n\n```", "```\ndata SpineStrictList a = Nil | Cons a (SpineStrictList a)\n\ninstance NFData a => NFData (SpineStrictList a) where\n    rnf Nil = ()\n    rnf (Cons x xs) = rnf x `seq` rnf xs\n\nmain = do\n    let l = ssFromListL ([1..1000000] :: [Int])\n        f x = ssMapL permute x\n    evaluate (rnf (f (f (f (f (f (f (f (f l)))))))))\n\nssFromListL [] = Nil\nssFromListL (x:xs) = Cons x (ssFromListL xs)\nssMapL _ Nil = Nil\nssMapL f (Cons x xs) = Cons (f x) (ssMapL f xs)\n\n```", "```\nmain = do\n    let l = [1..1000000] :: [Int]\n        f x = map permute x\n    evaluate (rnf (f (f (f (f (f (f (f (f l)))))))))\n\n```"]