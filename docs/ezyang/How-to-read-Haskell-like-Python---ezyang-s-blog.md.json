["```\nrunCommand env cmd state = ...\nretrieveState = ...\nsaveState state = ...\n\nmain :: IO ()\nmain = do\n    args <- getArgs\n    let (actions, nonOptions, errors) = getOpt Permute options args\n    opts <- foldl (>>=) (return startOptions) actions\n    when (null nonOptions) $ printHelp >> throw NotEnoughArguments\n    command <- fromError $ parseCommand nonOptions\n    currentTerm <- getCurrentTerm\n    let env = Environment\n            { envCurrentTerm = currentTerm\n            , envOpts = opts\n            }\n    saveState =<< runCommand env command =<< retrieveState\n\n```", "```\ndoThisThing a b c = ...\n  ==>\ndef doThisThing(a, b, c):\n  ...\n\n```", "```\nlet a = b + c in ...\n  ==>\na = b + c\n...\n\n```", "```\na <- createEntry x\n  ==>\na = createEntry(x)\n\n```", "```\nx = g(a + b)\ny = f(x)\n\n```", "```\ndoSomething >>= doSomethingElse >>= finishItUp\n  ==>\nx = doSomething()\ny = doSomethingElse(x)\nfinishItUp(y)\n\n```", "```\nz <- finishItUp =<< doSomethingElse =<< doSomething\n  ==>\nx = doSomething()\ny = doSomethingElse(x)\nz = finishItUp(y)\n\n```", "```\ndoSomething >> doSomethingElse\n  ==>\ndoSomething()\ndoSomethingElse()\n\n```", "```\ncase moose of\n  Foo x y z -> x + y * z\n  Bar z -> z * 3\n  ==>\nif isinstance(moose, Foo):\n  x = moose.x # the variable binding!\n  y = moose.y\n  z = moose.z\n  return x + y * z\nelif isinstance(moose, Bar):\n  z = moose.z\n  return z * 3\nelse:\n  raise Exception(\"Pattern match failure!\")\n\n```", "```\nwithFile \"foo.txt\" ReadMode $ \\h -> do\n  ...\n  ==>\nwith open(\"foo.txt\", \"r\") as h:\n  ...\n\n```", "```\ntrySomething x `catch` \\(e :: IOException) -> handleError e\n  ===\ncatch (trySomething x) (\\(e :: IOException) -> handleError e)\n  ==>\ntry:\n  trySomething(x)\nexcept IOError as e:\n  handleError(e)\n\n```", "```\nmaybe someDefault (\\x -> ...) mx\n  ==>\nif mx is None:\n  x = someDefault\nelse:\n  x = mx\n...\n\n```", "```\nmaybe (error \"bad value!\") (\\x -> ...) x\n  ==>\nif x is None:\n  raise Exception(\"bad value!\")\n\n```", "```\ndata NoNames = NoNames Int Int\ndata WithNames = WithNames {\n  firstField :: Int,\n  secondField :: Int\n}\n\n```", "```\nclass WithNames:\n  def __init__(self, firstField, secondField):\n    self.firstField = firstField\n    self.secondField = secondField\n\n```", "```\nreturn $ x { field = 2 }\n  ==>\ny = copy(x)\ny.field = 2\nreturn y\n\n```", "```\n[ x * y | x <- xs, y <- ys, y > 2 ]\n  ==>\n[ x * y for x in xs for y in ys if y > 2 ]\n\n```", "```\ndo\n  x <- xs\n  y <- ys\n  guard (y > 2)\n  return (x * y)\n\n```", "```\nrunCommand env cmd state = ...\nretrieveState = ...\nsaveState state = ...\n\nmain :: IO ()\nmain = do\n    args <- getArgs\n    let (actions, nonOptions, errors) = getOpt Permute options args\n    opts <- foldl (>>=) (return startOptions) actions\n    when (null nonOptions) $ printHelp >> throw NotEnoughArguments\n    command <- fromError $ parseCommand nonOptions\n    currentTerm <- getCurrentTerm\n    let env = Environment\n            { envCurrentTerm = currentTerm\n            , envOpts = opts\n            }\n    saveState =<< runCommand env command =<< retrieveState\n\n```", "```\ndef runCommand(env, cmd, state):\n   ...\ndef retrieveState():\n   ...\ndef saveState(state):\n   ...\n\ndef main():\n  args = getArgs()\n  (actions, nonOptions, errors) = getOpt(Permute(), options, args)\n  opts = **mumble**\n  if nonOptions is None:\n     printHelp()\n     raise NotEnoughArguments\n  command = parseCommand(nonOptions)\n\n  currentTerm = getCurrentTerm()\n  env = Environment(envCurrentTerm=currentTerm, envOpts=opts)\n\n  state = retrieveState()\n  result = runCommand(env, command, state)\n  saveState(result)\n\n```"]