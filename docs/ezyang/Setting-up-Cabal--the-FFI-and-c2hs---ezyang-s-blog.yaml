- en: <!--yml
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: 未分类'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 'category: 未分类'
- en: 'date: 2024-07-01 18:18:16'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 'date: 2024-07-01 18:18:16'
- en: -->
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: 'Setting up Cabal, the FFI and c2hs : ezyang’s blog'
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 Cabal、FFI 和 c2hs：ezyang 的博客
- en: 来源：[http://blog.ezyang.com/2010/06/setting-up-cabal-the-ffi-and-c2hs/](http://blog.ezyang.com/2010/06/setting-up-cabal-the-ffi-and-c2hs/)
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来源：[http://blog.ezyang.com/2010/06/setting-up-cabal-the-ffi-and-c2hs/](http://blog.ezyang.com/2010/06/setting-up-cabal-the-ffi-and-c2hs/)
- en: This part two of a [six part introduction to c2hs](http://blog.ezyang.com/2010/06/the-haskell-preprocessor-hierarchy/).
    Today, we discuss getting the damn thing to compile in the first place.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 [c2hs 六部分介绍的第二部分](http://blog.ezyang.com/2010/06/the-haskell-preprocessor-hierarchy/)。今天，我们讨论的是首次编译这个该死的东西。
- en: '*Reader prerequisites.* You should know how to write, configure and build a
    vanilla Cabal file for pure Haskell. Fortunately, with [cabal init](http://byorgey.wordpress.com/2010/04/15/cabal-init/),
    this is easier than ever. I''ll talk about how to setup a Cabal file for linking
    in C files, which is applicable to any sort of FFI writing (as it turns out, enabling
    c2hs is the trivial bit).'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*读者先决条件.* 你应该知道如何为纯 Haskell 编写、配置和构建一个普通的 Cabal 文件。幸运的是，通过 [cabal init](http://byorgey.wordpress.com/2010/04/15/cabal-init/)，现在比以往任何时候都更容易。我将讨论如何为链接
    C 文件设置 Cabal 文件，这对于任何类型的 FFI 编写都适用（事实证明，启用 c2hs 只是小菜一碟）。'
- en: '*Enabling c2hs.* Trick question; Cabal will automatically detect files with
    the extension `chs` and run `c2hs` with appropriate flags on them. However, since
    this operation might fail if the user hasn''t installed `c2hs`, you should add
    the following line to your Cabal file:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*启用 c2hs.* 这是一个技巧性问题；Cabal 会自动检测扩展名为 `chs` 的文件，并对其使用适当的标志运行 `c2hs`。然而，如果用户没有安装
    `c2hs`，这个操作可能会失败，因此你应该将以下行添加到你的 Cabal 文件中：'
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You should be able to compile an empty Haskell module that has `chs` as its
    file extension now.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该能够编译一个以 `chs` 作为文件扩展名的空 Haskell 模块了。
- en: (There is some Cabal hook code for adding c2hs preprocessor support, but it
    is completely unnecessary.)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: （这里有一些用于添加 c2hs 预处理器支持的 Cabal 钩子代码，但完全不必要。）
- en: '*Looking at the resulting hs.* Once a `chs` file has been preprocessed, Cabal
    will not look at it any more. You should not be afraid of looking at the preprocessor
    output; in many cases, it will be far more elucidating when you''re trying to
    fix a type error. In general, the `hs` file will be located in the `dist/build`
    directory, as this build message (generated by GHC, not c2hs) shows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*查看生成的 hs 文件.* 一旦 `chs` 文件被预处理，Cabal 就不会再查看它了。你不应该害怕查看预处理器的输出；在许多情况下，当你试图修复类型错误时，这些输出会更有启发性。一般来说，`hs`
    文件会位于 `dist/build` 目录下，正如这条构建消息（由 GHC 而非 c2hs 生成）所示：'
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The code you see will look something like this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到的代码会类似于这样：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `LINE` pragmas ensure that when a type error is generated by the resulting
    Haskell code, you will get back line numbers that refer to the original `chs`
    file. This is not error-proof; sometimes errors will show up one or two lines
    where c2hs claims the error is.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`LINE` pragma 会确保当由生成的 Haskell 代码引起类型错误时，你会得到指向原始 `chs` 文件的行号。这并不是绝对可靠的；有时错误会在
    c2hs 声称错误所在的行号之前或之后出现。'
- en: '*Imports and language features.* c2hs generates Haskell code that needs some
    language features and imports. You should explicitly add the `ForeignFunctionInterface`
    language pragma to the top of your program; while it is possible to enable this
    via the Cabal file, it''s good form to make your hs files as standalone as possible.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*导入和语言特性.* c2hs 生成的 Haskell 代码需要一些语言特性和导入。你应该明确地在程序的顶部添加 `ForeignFunctionInterface`
    语言 pragma；虽然可以通过 Cabal 文件启用它，但最好使你的 hs 文件尽可能独立。'
- en: 'In the current version of c2hs, module imports are a little more subtle. c2hs
    has a legacy module named C2HS that performs imports, re-exports and extra marshalling
    functions (necessary only if you''re using `fun`) that C2HS may generate by default.
    However, it is on its way to the dustbin, and the c2hs Cabal package doesn''t
    actually supply this module: you need to copy it into your source directory with
    `c2hs -l`. This module depends on `haskell98`. You should *not* re-export this
    module, so it should go in your `Other-modules` Cabal field.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前版本的 c2hs 中，模块导入稍微复杂一些。c2hs 有一个名为 C2HS 的遗留模块，执行导入、重新导出和额外的编组函数（只有在使用 `fun`
    时才需要），默认情况下 c2hs 可能会生成。然而，它已经快被抛弃了，而 c2hs Cabal 包实际上并没有提供这个模块：你需要用 `c2hs -l` 将它复制到你的源目录中。这个模块依赖于
    `haskell98`。你不应该重新导出这个模块，因此它应该放在你的 Cabal 文件的 `Other-modules` 字段中。
- en: The modern approach is to do the imports and definitions explicitly yourself.
    The modules to import are `Foreign` and `Foreign.C`, and there is a small assortment
    of marshalling functions that Haskell will complain are not defined when you try
    to use `fun` with that marshaller. Future versions of c2hs will further reduce
    the necessary functions. gtk2hs takes this approach (although they also forgo
    most of C2HS's automated marshalling support).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现代的方法是显式地导入和定义自己的模块。需要导入的模块是`Foreign`和`Foreign.C`，并且有一小部分与Haskell将在你尝试使用该编码器与其一起使用时，Haskell将会抱怨没有定义。将来的C2HS版本将进一步减少必要的函数。gtk2hs采用这种方法（尽管他们还放弃了大部分C2HS的自动编码支持）。
- en: '*Loading the library.* If you are lucky, your package manager has the library
    you''d like to create bindings for available. In this case, you only need to add
    the name of the library to `Extra-libraries` in the `Library` section of your
    Cabal. For example, if you want to use readline, add `readline` to your field,
    and GHC will know to find the headers in `/usr/include/readline` and dynamically
    link in `/usr/lib/libreadline.so`. In some cases, a library will install itself
    in a standard location that is not searched for by default (for example, Oracle
    on Linux systems, and basically any library on Windows); in this case, you can
    tell Cabal where this "non-standard standard" location is with `Extra-lib-dirs`.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*加载库。* 如果幸运的话，你的包管理器已经有了你想要创建绑定的库。在这种情况下，你只需将库的名称添加到Cabal文件中`Library`部分的`Extra-libraries`字段即可。例如，如果你想使用readline，就将`readline`添加到字段中，GHC将会知道在`/usr/include/readline`找到头文件，并在运行时动态链接`/usr/lib/libreadline.so`。在某些情况下，库会安装在默认情况下不会搜索的标准位置（例如Linux系统上的Oracle，以及Windows上的基本任何库）；在这种情况下，你可以告诉Cabal这个“非标准标准”位置在哪里，使用`Extra-lib-dirs`。'
- en: 'If your C library is not a good citizen (which is the case with many niche
    libraries), some extra steps need to be taken. Here are some common situations,
    and suggestions for how to deal with them:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的C库不是一个良好的模块（许多小众库就是这种情况），就需要采取一些额外步骤。以下是一些常见情况，以及如何处理它们的建议：
- en: '*The library is small and has a simple build process.* In this case, it is
    feasible to bundle the library''s source with your package and manage its compilation
    entirely with Cabal. If your library offers no `make install`, this may be your
    *only* option, besides asking your users to manually supply the necessary linker
    options to hook up the two installs (not a very user-friendly option, in particular,
    it makes running `cabal install` complicated). You should only do this with small
    amounts of source code, since the GHC-directed compilation is much slower than
    a usual build. See *Compiling the library with Cabal* and *Managing includes.*'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*这个库很小且构建过程简单。* 在这种情况下，可以将库的源代码与你的包捆绑在一起，并完全使用Cabal管理其编译。如果你的库没有`make install`，那么除了要求用户手动提供必要的链接器选项来连接这两个安装之外（这并不是一个用户友好的选项，特别是使得运行`cabal
    install`变得复杂）。你应该只在少量源代码的情况下这样做，因为与通常的构建相比，GHC指导的编译速度要慢得多。详见*使用Cabal编译库*和*管理包含文件*。'
- en: '*I want to bundle the library for X reason, but its build process is complicated.*
    In such a case, it is possible to setup Cabal to call the libraries build process,
    and then use the resulting files for the Haskell build process. There are numerous
    disadvantages to this, including a messy Cabal file and a messy install process,
    so if you''re able to do (3), I recommend that instead. See *Compiling the library
    with hooks* for details. You should also read *Managing includes.*'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*出于某些原因，我想捆绑这个库，但它的构建过程很复杂。* 在这种情况下，可以设置Cabal来调用库的构建过程，然后使用生成的文件进行Haskell构建过程。这种方法存在许多缺点，包括Cabal文件和安装过程混乱，因此如果你能够选择第三个选项，我建议使用那个。详见*使用挂钩编译库*。你还应该阅读*管理包含文件*。'
- en: '*I don''t want to bundle the library.* In this case, you will need to give
    instructions for end-users to download, compile and install the external library.
    It will be a lot easier for users if you, the package author, go and package the
    library for various distributions, so that it becomes a well-behaved, albeit seldom
    installed, library. If a user is unwilling to install the library in the canonical
    paths, they will need to pass `cabal` the appropriate options. See *Manual linking.*'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*我不想捆绑这个库。* 在这种情况下，你需要提供给最终用户下载、编译和安装外部库的指南。如果你作为包的作者，将该库打包为各种发行版的工作将会使用户的操作变得更加简单，尽管这是一个安装较少的库。如果用户不愿意在规范路径安装该库，他们将需要向`cabal`传递适当的选项。参见*手动链接*。'
- en: '*Compiling the library with Cabal.* Cabal has the ability to compile C code
    in a very simple fashion: it takes a list of files from the Cabal field `C-sources`
    and compiles them in that order. In particular, it doesn''t do any dependency
    tracking, so when you feed it the list of files, make sure they''re in the right
    order! This makes this mechanism appropriate only for small amounts of C, including
    C that you may write yourself to aid the binding process. There is a growing convention
    to place `c` files in `cbits`, and `h` files in `include`. You can then tell Cabal
    about these directories with the following lines:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用Cabal编译库.* Cabal有能力以非常简单的方式编译C代码：它从Cabal字段`C-sources`中获取文件列表并按顺序编译它们。特别地，它不执行任何依赖跟踪，因此当你提供文件列表时，请确保它们的顺序正确！这使得这种机制只适用于少量的C代码，包括您可能自己编写以帮助绑定过程的C代码。在`cbits`中放置`c`文件，并在`include`中放置`h`文件是一种日益普遍的惯例。然后，你可以使用以下几行告诉Cabal这些目录的位置：'
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'A few words about the "includes" fields:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 关于“includes”字段的几句话：
- en: The `Includes` field will probably not make a user-visible difference when the
    compilation goes well. However, it is good form to specify because Cabal will
    then go and check that those include files exist and are usable prior to compilation,
    giving the user a better error message if there are problems. *Usage.* Specify
    any standard headers and any bundled headers that your package uses.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当编译顺利进行时，`Includes`字段可能不会对用户造成显著影响。然而，明确指定它是个好习惯，因为Cabal会在编译之前检查这些包含文件是否存在并且可用，从而在出现问题时为用户提供更好的错误消息。*用法.*
    指定任何标准头文件和包含在你的软件包中使用的任何捆绑头文件。
- en: The `Install-includes` field will cause Cabal to place those header files in
    a public location upon installation. This is necessary for older versions of GHC
    to compile your code or if modules that use your module need to perform C includes
    of your library or `cbits`; it's generally good form to install your headers.
    *Usage.* Specify just the bundled headers that your package uses and exports.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Install-includes`字段将导致Cabal在安装时将这些头文件放置在公共位置。这对于旧版本的GHC编译您的代码或者如果使用您的模块的模块需要执行C包含您的库或`cbits`是必需的；通常情况下，安装您的头文件是一个很好的做法。*用法.*
    指定您的软件包使用和导出的捆绑头文件。'
- en: '*Compiling the library with hooks.* If there are over a dozen C files to be
    compiled, you may want to let the traditional `configure && make` process handle
    things for you. In this case, it may be appropriate to setup a small hook in Cabal''s
    `Setup.hs` using the experimental hooks interface to invoke the compilation. Here
    is a simple sample build script:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用钩子编译库.* 如果有超过一打的C文件需要编译，你可能希望让传统的`configure && make`流程为你处理。在这种情况下，使用Cabal的`Setup.hs`中的小钩子设置可能是合适的，通过实验性钩子接口来调用编译过程。以下是一个简单的示例构建脚本：'
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We've added our own `makeLib` build script to the `preBuild` (while preserving
    the old `simpleUserHooks` version), and use a Cabal utility function `rawSystemExit`
    to do most of the lifting for us. Notice that `--directory=abc` needed to be passed
    to `make`; Cabal runs in the same directory as the `cabal` file, and so you'll
    probably need to adjust your working directory to the library directory. `setCurrentDirectory`
    may come in handy.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`preBuild`中添加了我们自己的`makeLib`构建脚本（同时保留旧版本的`simpleUserHooks`），并使用Cabal的实用函数`rawSystemExit`来完成大部分工作。请注意，需要将`--directory=abc`传递给`make`；Cabal在与`cabal`文件相同的目录中运行，因此你可能需要调整你的工作目录到库目录。`setCurrentDirectory`可能会派上用场。
- en: Your build process will probably place the resulting `libfoo.a` file somewhere
    *not* `dist/build`. You can tell Cabal to look in that directory using the `Extra-lib-dirs`
    field.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你的构建过程可能会将生成的`libfoo.a`文件放在*不是*`dist/build`的某个地方。你可以使用`Extra-lib-dirs`字段告诉Cabal查找那个目录。
- en: The above steps are enough to get a clean source checkout of your software working,
    but to ensure that users will be able to install the result of `cabal sdist`,
    you will need to go a little further.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 上述步骤足以使你的软件的干净源码检查工作正常进行，但是为了确保用户能够安装`cabal sdist`的结果，你需要再进一步。
- en: First, *any* source file that the build processes you will need to explicitly
    list in `Extra-source-files`. Cabal only affords a limited form of globbing, which
    must be in the filename and contain a file extension, so this list can get quite
    long (and we recommend you generate it with a script.)
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，任何构建过程中需要的*任何*源文件都必须在`Extra-source-files`中显式列出。Cabal只支持一种有限的通配符匹配形式，文件名必须包含文件扩展名，所以这个列表可能会很长（我们建议你使用脚本生成它）。
- en: 'Second, the static/dynamic libraries that the build process creates probably
    will not be placed in a place that GHC will look when compiling, resulting in
    this error:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，构建过程创建的静态/动态库可能不会放置在 GHC 编译时会查找的位置，导致此错误：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can place our library in the same place where Cabal places the static libraries
    of Haskell modules during installation with another hook:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在与 Cabal 在安装期间放置 Haskell 模块的静态库相同的位置放置我们的库，这需要另一个钩子：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The incant to the right of `libPref` determines where Cabal is going to install
    the library files, and then we simply copy our libraries to that location.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`libPref`右侧的咒语决定了 Cabal 将要安装库文件的位置，然后我们只需将我们的库复制到该位置。'
- en: (*Nota bene.* You should really only use this trick if you're sure no one is
    going to install this library globally, because having non-binary compatible libraries
    floating around with the same name is *no fun at all.*)
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: （*Nota bene.* 如果你确信没有人会全局安装此库，那么只有在确保库不与同名的非二进制兼容库一起浮动时才真正使用此技巧是*非常有趣的*。）
- en: '*Managing includes.* Any non-standard directories that need to be in the include
    path should be added to `Include-dirs`. If there are a *lot* of such directories
    in the library, consider an alternate solution: create symlinks to all of the
    relevant header files in `include` and then just add that directory to `Include-dirs`.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*管理包含。* 任何需要位于包含路径中的非标准目录应添加到`Include-dirs`。如果库中有*很多*这样的目录，请考虑另一种解决方案：在`include`中为所有相关头文件创建符号链接，然后只需将该目录添加到`Include-dirs`。'
- en: '*Manual linking.* If you need to manually tell Cabal where the relevant headers
    and libraries are, you can use the `--extra-include-dirs` and `--extra-lib-dirs`
    flags with `cabal configure` or `cabal install`. They function just like `Include-dirs`
    and `Extra-lib-dirs`.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*手动链接。* 如果需要手动告诉 Cabal 相关头文件和库的位置，你可以在`cabal configure`或`cabal install`中使用`--extra-include-dirs`和`--extra-lib-dirs`标志。它们的功能与`Include-dirs`和`Extra-lib-dirs`完全相同。'
- en: '*Cohabiting Library and Executable sections.* You may find it convenient to
    define a number of `Executable` sections in your Cabal file for testing, in which
    case you''ll notice that you seem to need to duplicate all of the C-related Cabal
    fields to each of your executable sections. Well, in Cabal 1.8.0.4, you can now
    set `Build-depends` to point to your same package ("self-reference"); so you declare
    a `Build-depends` on your own package for each executable and the C-related Cabal
    fields are unnecessary.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*共存的库和可执行部分。* 对于测试，你可能会发现在你的 Cabal 文件中定义多个`Executable`部分很方便，在这种情况下，你会注意到似乎需要将所有与
    C 相关的 Cabal 字段复制到每个可执行部分中。好吧，在 Cabal 1.8.0.4 中，你现在可以将`Build-depends`设置为指向你自己的包（"self-reference"）；因此，你为每个可执行文件声明了一个`Build-depends`，而与
    C 相关的 Cabal 字段是不必要的。'
- en: 'You will need to tell Cabal that it''s OK to use this feature with this field:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要告诉 Cabal 可以使用此字段来使用这个特性：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Postscript.* Thanks Duncan Coutts for helping clarify and suggest improvements
    sections of this tutorial.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*附言。* 感谢 Duncan Coutts 帮助澄清和建议改进本教程的各个部分。'
- en: '*Next time.* [Principles of FFI API design](http://blog.ezyang.com/2010/06/principles-of-ffi-api-design/).'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*下次再说。* [FFI API 设计原则](http://blog.ezyang.com/2010/06/principles-of-ffi-api-design/)。'
