["```\n(cons 2 (cdr (cdr (car (car x)))))\n\n```", "```\nsum (map (+2) (toList (transform inputMap)))\n\n```", "```\nsum $ map (+2) $ toList $ transform inputMap\n\n```", "```\nsum . map (+2) . toList . transform $ inputMap\n\n```", "```\n(h (g (f expr)))\n\n```", "```\n(h (g (f ____)))\n\n```", "```\n(lambda (x) (h (g (f x))))\n\n```", "```\nh . g . f\n\n```", "```\nnewtype Cont r a = Cont { runCont :: (a -> r) -> r }\ninstance Monad (Cont r) where\n  return x = Cont (\\k -> k x)\n  (Cont c) >>= f = Cont (\\k -> c (\\r -> runCont (f r) k))\n\n```", "```\ninstance Functor (Cont r) where\n  fmap f = \\c -> Cont (\\k -> runCont c (k . f))\n\n```", "```\ng . f\n\n```", "```\n\\k -> k . (g . f)\n\n```", "```\n\\x k -> (k . g . f $ x)\n\n```", "```\n\\k1 -> k1 . (g . f) $ \\k2 -> k2 . h\n(\\k2 -> k2 . h) . (g . f)\n\n```", "```\n\\k2 -> k2 . h . (g . f)\n\n```", "```\n\\k -> (\\k1 -> k1 . (g . f)) (\\r -> (\\k2 -> k2 . h) k r)\n      \\-- 1st lifted fn --/         \\-- 2nd fn --/\n\n```", "```\ncallCC f = Cont (\\k -> runCont (f (\\x -> Cont (\\_ -> k a))) k)\n\n```", "```\n\\succ fail -> either fail succ . h . g . f\n\n```", "```\n\\succ _ -> succ . fromRight . h . g . f\n\n```", "```\n\\_ fail -> fail . fromLeft . h . g . f\n\n```"]