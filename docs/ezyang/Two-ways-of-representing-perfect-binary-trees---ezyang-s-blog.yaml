- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-07-01 18:17:29'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: 'Two ways of representing perfect binary trees : ezyang’s blog'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[http://blog.ezyang.com/2012/08/statically-checked-perfect-binary-trees/](http://blog.ezyang.com/2012/08/statically-checked-perfect-binary-trees/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'A common simplification when discussing many divide and conquer algorithms
    is the assumption that the input list has a size which is a power of two. As such,
    one might wonder: *how do we encode lists that have power of two sizes*, in a
    way that lists that don’t have this property are unrepresentable? One observation
    is that such lists are *perfect binary trees*, so if we have an encoding for perfect
    binary trees, we also have an encoding for power of two lists. Here are two well-known
    ways to do such an encoding in Haskell: one using GADTs and one using nested data-types.
    We claim that the nested data-types solution is superior.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This post is literate, but you will need some type system features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: GADTs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One approach is to encode the size of the tree into the type, and then assert
    that the sizes of two trees are the same. This is pretty easy to do with GADTs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'By reusing the type variable `i`, the constructor of `N` ensures that we any
    two trees we combine must have the same size. These trees can be destructed like
    normal binary trees:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating these trees from ordinary lists is a little delicate, since the `i`
    type variable needs to be handled with care. Existentials over lists work fairly
    well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Nested data-types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another approach is to literally build up a type isomorphic to a 2^n size tuple
    (modulo laziness). For example, in the case of a 4-tuple, we’d like to just say
    `((1, 2), (3, 4))`. There is still, however, the pesky question of how one does
    recursion over such a structure. The technique to use here is bootstrapping, described
    in Adam Buchsbaum in his thesis and popularized by Chris Okasaki:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how the recursive mention of `B` does not hold `a`, but `(a, a)`: this
    is so-called “non-uniform” recursion. Every time we apply a `Two` constructor,
    the size of our tuple doubles, until we top it off:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Which is better?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At first glance, the GADT approach seems more appealing, since when destructing
    it, the data type looks and feels a lot like an ordinary binary tree. However,
    it is much easier to parse user data into nested data types than GADTs (due to
    the fact that Haskell is not a dependently typed language). Ralf Hinze, in his
    paper [Perfect Trees and Bit-reversal Permutations](http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.46.1095),
    gives another argument in favor of nested datatypes:'
  prefs: []
  type: TYPE_NORMAL
- en: Comparing [perfect trees and the usual definition of binary trees] it is fairly
    obvious that the first representation is more concise than the second one. If
    we estimate the space usage of an *k*-ary constructor at *k+1* cells, we have
    that a perfect tree of rank *n* consumes *(2^n-1)3+(n+1)2* cells with the first
    and *(2^n-1)3+2*2^n* with the second. [The difference coming from all of the extra
    leaf nodes.]
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Nevertheless, destructing the nested data type tree is very weird, and we might
    feel better about the “exotic” nested data type if there was an efficient transformation
    from the catamorphism `(n :: t a -> t a -> t a , z :: a -> t a)` on traditional
    trees:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'to a catamorphism `(f :: a -> t a, g :: t (a, a) -> t a)` on our nested data-type
    tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This conversion is possible, though, alas, it is not a catamorphism:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The idea is to create a function `(a -> t a) -> t a`, which we then pass `z`
    in order to get the final result. This is the time honored difference list/continuation
    passing trick, where we build up a chain of function invocations rather than attempt
    to build up the result directly, since ordinarily the catamorphism on nested data-type
    trees proceeds in the wrong direction. But now, we can easily perform any fold
    we would have done on ordinary trees on our nested data-type trees, which resolves
    any lingering concerns we may have had. Nested data types are superior... from
    a representation size perspective, in any case. (See Jeremy's comment for another
    take on the issue, though.)
  prefs: []
  type: TYPE_NORMAL
- en: For further reading, check out [Generalised folds for nested datatypes](http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.42.1517)
    (Richard Bird, Ross Paterson).
  prefs: []
  type: TYPE_NORMAL
