["```\nclass DOMNode {\n  private DOMDocument $ownerDocument;\n  // ...\n  public void appendNode(DOMNode n) {\n    if (n.ownerDocument != this.ownerDocument) {\n      throw DOMException(\"Cannot append node that \"\n        \"does not belong to this document\");\n    }\n    // ...\n  }\n}\n\n```", "```\nclass DOMDocument {\n  public DOMNode importNode(DOMNode node) {\n    // ...\n  }\n}\n\n```", "```\nclass DOMNode {\n  private DOMNode $copy;\n}\n\n```", "```\n{-# LANGUAGE Rank2Types #-}\n-- s is the phantom type\nnewtype DOM s a = ...\nnewtype Node s = ...\nrunDom :: (forall s. DOM s ()) -> Document\ngetNodeById :: Id -> DOM s (Node s)\ndeleteNode :: Node s -> DOM s ()\n\n-- Does not typecheck, the second runDom uses a fresh\n-- phantom variable which does not match node's\nrunDom $ do\n  node <- getNodeById \"myNode\"\n  let alternateDocument = runDom $ do\n    deleteNode node\n\n```", "```\nimportNode :: Node s -> DOM s2 (Node s2)\nsetRoot :: Node s -> DOM s ()\n\n-- This now typechecks\nrunDom $ do\n  node <- getNodeById \"myNode\"\n  let alternateDocument = runDom $ do\n    node' <- importNode node\n    setRoot node'\n\n```", "```\n{-# LANGUAGE EmptyDataDecls #-}\ndata Dup n\ngetNewNode :: Node s -> DOM (Dup s) (Node (Dup s))\ndupDom :: DOM s () -> DOM s (DOM (Dup s) ())\n\n-- This typechecks, and does not recopy the original node\nrunDom $ do\n  node <- getNodeById \"myNode\"\n  dupDom $ do\n    node' <- getNewNode node\n    ...\n\n```"]