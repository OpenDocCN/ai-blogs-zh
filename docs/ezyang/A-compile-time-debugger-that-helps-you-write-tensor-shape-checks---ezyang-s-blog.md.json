["```\nmain() {\n  x = load(\"tensor1.t\")\n  y = load(\"tensor2.t\")\n  return matmul(x, y)\n}\n\n```", "```\n# Ahoy there Edward!  I stopped your program, because I could not\n# prove that execution of this line was definitely safe:\n\n   main() {\n     x = load(\"tensor1.t\")\n     y = load(\"tensor2.t\")\n->   return matmul(x, y)\n   }\n\n# Here's what's in scope:\n\n  _x_size : List(Nat)  # erases to x.size()\n  _y_size : List(Nat)  # erases to y.size()\n  x : Tensor(_x_size)\n  y : Tensor(_y_size)\n\n# I don't know anything else about these values\n\n```", "```\n> :t 1\n# Here's the type of 1, which you requested:\nNat\n\n> :t [1, 2, 0]\n# Here's the type of [1, 2, 0], which you requested:\nList(Nat)\n\n> :t matmul\n# Here's the type of matmul, which you requested:\nforall (a, b, c : Nat). (Tensor([a, b]), Tensor([b, c])) -> Tensor([a, c])\n\n```", "```\n> :t load\n# Here's the type of load, which you requested:\nString ~> exists (size : List(Nat)). Tensor(size)\n\n```", "```\n> matmul(x, y)\n\n# I'm sorry!  I was trying to find values of a, b and c which\n# would make the following equations true:\n#\n#     [a, b] = _x_size\n#     [b, c] = _y_size\n#\n# But I don't know anything about _x_size or _y_size (they are skolem\n# variables), so I couldn't do it.  Cowardly bailing out!\n\n```", "```\n> add\n# Here's the type of add, which you requested!\nadd : forall (size : List(Nat)). Tensor(size) -> Tensor(size) -> Tensor(size)\n\n> add(x, x)\nTensor(_x_size)\n\n# This type-checked OK!  I set size = _x_size and all of the arguments\n# checked out.  You're good to go.\n\n```", "```\n> :t assert_eq_nat!\n(x : Nat) -> (y : Nat) ~> x = y\n\n```", "```\n> assert_eq_nat!(len(_x_size), 2)\n\n# OK!  I added assert_eq_nat!(len(x.size()), 2) to your program, and\n# here's what I know now:\n\n  _x_size : List(Nat)\n  _y_size : List(Nat)\n  x : Tensor(_x_size)\n  y : Tensor(_y_size)\n  len(_x_size) = 2\n\n# By the way, I can profitably destruct _x_size into its constituent\n# parts; would you like to do this? (Y/n)\n\n> Y\n\n# OK, your new context is this:\n\n  _x0, _x1 : Nat\n  _y_size : List(Nat)\n  x : Tensor([_x0, _x1])\n  y : Tensor(_y_size)\n\n# I don't know anything about the new variables _x0 and _x1, but I\n# learned enough about _x_size that I was able to eliminate it from\n# the context (_x_size = [_x0, _x1])\n\n```", "```\n> assert_eq_nat!(len(_y_size), 2)\n\n# OK!  I added assert_eq_nat!(len(y.size()), 2) to your program, and\n# here's what I know now:\n\n  _x0, _x1 : Nat  # erases to x.size(0), x.size(1)\n  _y_size : List(Nat)\n  x : Tensor([_x0, _x1])\n  y : Tensor(_y_size)\n  len(_y_size) = 2\n\n# By the way, I can profitably destruct _y_size into its constituent\n# parts; would you like to do this? (Y/n)\n\n> Y\n\n# OK, your new context is this:\n\n  _x0, _x1 : Nat  # erases to x.size(0), x.size(1)\n  _y0, _y1 : Nat  # erases to y.size(0), y.size(1)\n  x : Tensor([_x0, _x1])\n  y : Tensor([_y0, _y1])\n\n# I don't know anything about the new variables _y0 and _y1, but I\n# learned enough about _y_size  that I was able to eliminate it from\n# the context (_y_size = [_y0, _y1])\n\n```", "```\n> assert_eq_nat!(_x1, _y0)\n\n# OK!  I added assert_eq_nat!(x.size(1), y.size(0)) to your program.\n# After doing this, I learned _x1 = _y0, so I replaced all occurrences\n# of _y0 with _x1\\. Now the context looks like this.\n\n  _x0, _x1 : Nat  # erases to x.size(0), x.size(1)\n  _y1 : Nat  # erases to y1.size(1)\n  x : Tensor([_x0, _x1])\n  y : Tensor([_x1, _y1])\n\n```", "```\n> matmul(x, y)\n\n# This type-checked OK!  I set a = _x0, b = _x1, c = _y1 and all of the\n# arguments checked out.  You're good to go.\n\n```", "```\n  main() {\n    x = load(\"tensor1.t\")\n    y = load(\"tensor2.t\")\n    assert_eq_nat!(x.size(), 2)\n    assert_eq_nat!(y.size(), 2)\n    assert_eq_nat!(x.size(1), y.size(0))\n    matmul(x, y)\n}\n\n```"]