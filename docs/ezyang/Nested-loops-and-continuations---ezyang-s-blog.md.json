["```\nimport Prelude hiding (break)\n\nloopLookForIt :: ContT () IO ()\nloopLookForIt =\n    for_in [0..100] $ \\loop x -> do\n        when (x `mod` 3 == 1) $ continue loop\n        when (x `div` 17 == 2) $ break loop\n        lift $ print x\n\n```", "```\nloopBreakOuter :: ContT () IO ()\nloopBreakOuter =\n    for_in [1,2,3] $ \\outer x -> do\n        for_in [4,5,6] $ \\inner y -> do\n            lift $ print y\n            break outer\n        lift $ print x\n\n```", "```\nrunContT loopBreakOuter return :: IO ()\n\n```", "```\ndata (MonadCont m) => Label m = Label {\n    continue :: m (),\n    break :: m ()\n}\n\n```", "```\nfor_in' :: (Monad m) => [a] -> (a -> m ()) -> m ()\nfor_in' xs f = mapM_ f xs\n\n```", "```\nfor_in'' :: (MonadCont m) => [a] -> (a -> m ()) -> m ()\nfor_in'' xs f = callCC $ \\c -> mapM_ f xs\n\n```", "```\nfor_in''' :: (MonadCont m) => [a] -> (a -> m ()) -> m ()\nfor_in''' xs f = mapM_ (\\x -> callCC $ \\c -> f x) xs\n\n```", "```\nfor_in :: (MonadCont m) => [a] -> (Label m -> a -> m ()) -> m ()\nfor_in xs f = callCC $ \\breakCont ->\n    mapM_ (\\x -> callCC $ \\continueCont -> f (Label (continueCont ()) (breakCont ())) x) xs\n\n```"]