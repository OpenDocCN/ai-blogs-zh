- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-07-01 18:18:14'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: 'Maximum matching deadlock solution : ezyang’s blog'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[http://blog.ezyang.com/2010/07/maximum-matching-deadlock-solution/](http://blog.ezyang.com/2010/07/maximum-matching-deadlock-solution/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Maximum matching deadlock solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Last Monday](http://blog.ezyang.com/2010/07/graphs-not-grids/), I presented
    a parallel algorithm for computing maximum weighted matching, and noted that on
    real hardware, a naive implementation would deadlock.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Several readers correctly identified that sorting the nodes on their most weighted
    vertex only once was insufficient: when a node becomes paired as is removed from
    the pool of unpaired nodes, it could drastically affect the sort. Keeping the
    nodes in a priority queue was suggested as an answer, which is certainly a good
    answer, though not the one that Feo ended up using.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Feo’s solution.* Assign every node an “is being processed bit.” When a node
    attempts to read its neighbor’s full/empty bit and finds the bit empty, check
    if the node is being processed. If it is not, atomically check and set the “is
    being processed bit” to 1 and process the node recursively. Fizzle threads that
    are scheduled but whose nodes are already being processed. The overhead is one
    bit per node.'
  prefs: []
  type: TYPE_NORMAL
- en: I think this is a particularly elegant solution, because it shows how recursion
    lets work easily allocate itself to threads that would otherwise be idle.
  prefs: []
  type: TYPE_NORMAL
