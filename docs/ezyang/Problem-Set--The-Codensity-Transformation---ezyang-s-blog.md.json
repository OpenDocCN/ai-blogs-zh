["```\n{-# LANGUAGE Rank2Types, MultiParamTypeClasses, FlexibleInstances #-}\nimport Prelude hiding (abs)\n\n_EXERCISE_ = undefined\n\n-----------------------------------------------------------------------------\n-- Warmup: Hughes lists\n-----------------------------------------------------------------------------\n\n-- Experienced Haskellers should feel free to skip this section.\n\n-- We first consider the problem of left-associative list append.  In\n-- order to see the difficulty, we will hand-evaluate a lazy language.\n-- For the sake of being as mechanical as possible, here are the\n-- operational semantics, where e1, e2 are expressions and x is a\n-- variable, and e1[e2/x] is replace all instances of x in e1 with e2.\n--\n--        e1 ==> e1'\n--   ---------------------\n--     e1 e2 ==> e1' e2\n--\n--   (\\x -> e1[x]) e2 ==> e1[e2/x]\n--\n-- For reference, the definition of append is as follows:\n--\n--      a ++ b = foldr (:) b a\n--\n-- Assume that, on forcing a saturated foldr, its third argument is\n-- forced, as follows:\n--\n--                e1 ==> e1'\n--    -----------------------------------\n--      foldr f e2 e1 ==> foldr f e2 e1'\n--\n--  foldr f e2 (x:xs) ==> f x (foldr f e2 xs)\n--\n-- Hand evaluate this implementation by forcing the head constructor,\n-- assuming 'as' is not null:\n\nlistsample as bs cs = (as ++ bs) ++ cs\n\n-- Solution:\n--\n--        (as ++ bs) ++ cs\n--      = foldr (:) cs (as ++ bs)\n--      = foldr (:) cs (foldr (:) bs as)\n--      = foldr (:) cs (foldr (:) bs (a:as'))\n--      = foldr (:) cs (a : foldr (:) b as')\n--      = a : foldr (:) cs (foldr (:) bs as')\n--\n-- Convince yourself that this takes linear time per append, and that\n-- processing each element of the resulting tail of the list will also\n-- take linear time.\n\n-- We now present Hughes lists:\n\ntype Hughes a = [a] -> [a]\n\nlistrep :: Hughes a -> [a]\nlistrep = _EXERCISE_\n\nappend :: Hughes a -> Hughes a -> Hughes a\nappend = _EXERCISE_\n\n-- Now, hand evaluate your implementation on this sample, assuming all\n-- arguments are saturated.\n\nlistsample' a b c = listrep (append (append a b) c)\n\n-- Solution:\n--\n--        listrep (append (append a b) c)\n--      = (\\l -> l []) (append (append a b) c)\n--      = (append (append a b) c) []\n--      = (\\z -> (append a b) (c z)) []\n--      = (append a b) (c [])\n--      = (\\z -> a (b z)) (c [])\n--      = a (b (c []))\n--\n-- Convince yourself that the result requires only constant time per\n-- element, assuming a, b and c are of the form (\\z -> a1:a2:...:z).\n-- Notice the left-associativity has been converted into\n-- right-associative function application.\n\n-- The codensity transformation operates on similar principles.  This\n-- ends the warmup.\n\n-----------------------------------------------------------------------------\n-- Case for leafy trees\n-----------------------------------------------------------------------------\n\n-- Some simple definitions of trees\n\ndata Tree a = Leaf a | Node (Tree a) (Tree a)\n\n-- Here is the obvious monad definition for trees, where each leaf\n-- is substituted with a new tree.\n\ninstance Monad Tree where\n    return = Leaf\n    Leaf a   >>= f = f a\n    Node l r >>= f = Node (l >>= f) (r >>= f)\n\n-- You should convince yourself of the performance problem with this\n-- code by considering what happens if you force it to normal form.\n\nsample = (Leaf 0 >>= f) >>= f\n    where f n = Node (Leaf (n + 1)) (Leaf (n + 1))\n\n-- Let's fix this problem.  Now abstract over the /leaves/ of the tree\n\nnewtype CTree a = CTree { unCTree :: forall r. (a -> Tree r) -> Tree r }\n\n-- Please write functions which witness the isomorphism between the\n-- abstract and concrete versions of trees.\n\ntreerep :: Tree a -> CTree a\ntreerep = _EXERCISE_\n\ntreeabs :: CTree a -> Tree a\ntreeabs = _EXERCISE_\n\n-- How do you construct a node in the case of the abstract version?\n-- It is trivial for concrete trees.\n\nclass Monad m => TreeLike m where\n    node :: m a -> m a -> m a\n    leaf :: a -> m a\n    leaf = return\n\ninstance TreeLike Tree where\n    node = Node\n\ninstance TreeLike CTree where\n    node = _EXERCISE_\n\n-- As they are isomorphic, the monad instance carries over too.  Don't\n-- use rep/abs in your implementation.\n\ninstance Monad CTree where\n    return = _EXERCISE_\n    (>>=)  = _EXERCISE_ -- try explicitly writing out the types of the arguments\n\n-- We now gain efficiency by operating on the /abstracted/ version as\n-- opposed to the ordinary one.\n\ntreeimprove :: (forall m. TreeLike m => m a) -> Tree a\ntreeimprove m = treeabs m\n\n-- You should convince yourself of the efficiency of this code.\n-- Remember that expressions inside lambda abstraction don't evaluate\n-- until the lambda is applied.\n\nsample' = treeabs ((leaf 0 >>= f) >>= f)\n    where f n = node (leaf (n + 1)) (leaf (n + 1))\n\n-----------------------------------------------------------------------------\n-- General case\n-----------------------------------------------------------------------------\n\n-- Basic properties about free monads\n\ndata Free f a = Return a | Wrap (f (Free f a))\ninstance Functor f => Monad (Free f) where\n    return = _EXERCISE_\n    (>>=)  = _EXERCISE_ -- tricky!\n\n-- Leafy trees are a special case, with F as the functor. Please write\n-- functions which witness this isomorphism.\n\ndata F a = N a a\n\nfreeFToTree :: Free F a -> Tree a\nfreeFToTree = _EXERCISE_\n\ntreeToFreeF :: Tree a -> Free F a\ntreeToFreeF = _EXERCISE_\n\n-- We now define an abstract version of arbitrary monads, analogous to\n-- abstracted trees.  Witness an isomorphism.\n\nnewtype C m a = C { unC :: forall r. (a -> m r) -> m r }\n\nrep :: Monad m => m a -> C m a\nrep = _EXERCISE_\n\nabs :: Monad m => C m a -> m a\nabs = _EXERCISE_\n\n-- Implement the monad instance from scratch, without rep/abs.\n\ninstance Monad (C m) where\n    return = _EXERCISE_\n    (>>=)  = _EXERCISE_ -- also tricky; if you get stuck, look at the\n                        -- implementation for CTrees\n\n-- By analogy of TreeLike for free monads, this typeclass allows\n-- the construction of non-Return values.\n\nclass (Functor f, Monad m) => FreeLike f m where\n    wrap :: f (m a) -> m a\n\ninstance Functor f => FreeLike f (Free f) where\n    wrap = Wrap\n\ninstance FreeLike f m => FreeLike f (C m) where\n    -- Toughest one of the bunch. Remember that you have 'wrap' available for the\n    -- inner type as well as functor and monad instances.\n    wrap = _EXERCISE_\n\n-- And for our fruits, we now have a fully abstract improver!\n\nimprove :: Functor f => (forall m. FreeLike f m => m a) -> Free f a\nimprove m = abs m\n\n-- Bonus: Why is the universal quantification over 'r' needed?   What if\n-- we wrote C r m a = ...?  Try copypasting your definitions for that\n-- case.\n\n```"]