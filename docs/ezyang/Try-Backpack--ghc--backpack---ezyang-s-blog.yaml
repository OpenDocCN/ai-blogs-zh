- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-07-01 18:17:05'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: 'Try Backpack: ghc –backpack : ezyang’s blog'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[http://blog.ezyang.com/2016/10/try-backpack-ghc-backpack/](http://blog.ezyang.com/2016/10/try-backpack-ghc-backpack/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Backpack](https://ghc.haskell.org/trac/ghc/wiki/Backpack), a new system for
    mix-in packages in Haskell, has been released with GHC 8.2\. Although Backpack
    is closely integrated with the Cabal package system, it''s still possible to play
    around with toy examples using a new command `ghc --backpack`. Before you get
    started, make sure you have a [recent enough version of GHC](https://ghc.haskell.org/trac/ghc/blog/ghc-8.2.11-released):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'By the way, if you want to jump straight into Backpack for real (with Cabal
    packages and everything), skip this tutorial and jump to [Try Backpack: Cabal
    packages](http://blog.ezyang.com/2017/01/try-backpack-cabal-packages/).'
  prefs: []
  type: TYPE_NORMAL
- en: Hello World
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: GHC supports a new file format, `bkp` files, which let you easily define multiple
    modules and packages in a single source file, making it easy to experiment with
    Backpack. This format is not suitable for large scale programming (there isn't
    any integration of `bkp` files with Cabal, nor do we plan to add an such integration),
    but we will use it for our tutorial because it makes it very easy to play around
    with Backpack without mucking about with lots of Cabal packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple "Hello World" program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We define a unit (think package) with the special name `main`, and in it define
    a `Main` module (also specially named) which contains our `main` function. Place
    this in a file named `hello.bkp`, and then run `ghc --backpack hello.bkp` (using
    your GHC nightly). This will produce an executable at `main/Main` which you can
    run; you can also explicitly specify the desired output filename using `-o filename`.
    Note that by default, `ghc --backpack` creates a directory with the same name
    as every unit, so `-o main` won't work (it'll give you a linker error; use a different
    name!)
  prefs: []
  type: TYPE_NORMAL
- en: A Play on Regular Expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's write some nontrivial code that actually uses Backpack. For this tutorial,
    we will write a simple matcher for regular expressions as described in [A Play
    on Regular Expressions](https://sebfisch.github.io/haskell-regexp/regexp-play.pdf)
    (Sebastian Fischer, Frank Huch, Thomas Wilke). The matcher itself is inefficient
    (it checks for a match by testing all exponentially many decompositions of a string),
    but it will be sufficient to illustrate many key concepts of Backpack.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start things off, let''s go ahead and write a traditional implementation
    of the matcher by copy-pasting the code from this Functional Pearl into a `Regex`
    module in the Backpack file and writing a little test program to run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If you put this in `regex.bkp`, you can once again compile it using `ghc --backpack
    regex.bkp` and invoke the resulting executable at `main/Main`. It should print
    `True`.
  prefs: []
  type: TYPE_NORMAL
- en: Functorizing the matcher
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The previously shown code isn't great because it hardcodes `String` as the type
    to do regular expression matching over. A reasonable generalization (which you
    can see in the original paper) is to match over arbitrary lists of symbols; however,
    we might also reasonably want to match over non-list types like `ByteString`.
    To support all of these cases, we will instead use Backpack to "functorize" (in
    ML parlance) our matcher.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll do this by creating a new unit, `regex-indef`, and writing a signature
    which provides a string type (we''ve decided to call it `Str`, to avoid confusion
    with `String`) and all of the operations which need to be supported on it. Here
    are the steps I took:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, I copy-pasted the old `Regex` implementation into the new unit. I replaced
    all occurrences of `String` with `Str`, and deleted `splits` and `parts`: we will
    require these to be implemented in our signature.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we create a new `Str` signature, which is imported by `Regex`, and defines
    our type and operations (`splits` and `parts`) which it needs to support:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At this point, I ran `ghc --backpack` to typecheck the new unit. But I got two
    errors!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Traversable `null` nonsense aside, the errors are quite clear: `Str` is a completely
    abstract data type: we cannot assume that it is a list, nor do we know what instances
    it has. To solve these type errors, I introduced the combinators `null` and `singleton`,
    an `instance Eq Str`, and rewrote `Regex` to use these combinators (a very modest
    change.) (Notice we can''t write `instance Traversable Str`; it''s a kind mismatch.)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here is our final indefinite version of the regex unit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: (To keep things simple for now, I haven't parametrized `Char`.)
  prefs: []
  type: TYPE_NORMAL
- en: Instantiating the functor (String)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is all very nice but we can''t actually run this code, since there is
    no implementation of `Str`. Let''s write a new unit which provides a module which
    implements all of these types and functions with `String`, copy pasting in the
    old implementations of `splits` and `parts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: One quirk when writing Backpack implementations for functions is that Backpack
    does *no* subtype matching on polymorphic functions, so you can't implement `Str
    -> Bool` with a polymorphic function `Traversable t => t a -> Bool` (adding this
    would be an interesting extension, and not altogether trivial). So we have to
    write a little impedance matching binding which monomorphizes `null` to the expected
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'To instantiate `regex-indef` with `str-string:Str`, we modify the dependency
    in `main`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Backpack files require instantiations to be explicitly specified (this is as
    opposed to Cabal files, which do mix-in linking to determine instantiations).
    In this case, the instantiation specifies that `regex-indef`'s signature named
    `Str` should be filled with the `Str` module from `str-string`.
  prefs: []
  type: TYPE_NORMAL
- en: After making these changes, give `ghc --backpack` a run; you should get out
    an identical looking result.
  prefs: []
  type: TYPE_NORMAL
- en: Instantiating the functor (ByteString)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The whole point of parametrizing `regex` was to enable us to have a second
    implementation of `Str`. So let''s go ahead and write a `bytestring` implementation.
    After a little bit of work, you might end up with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two things to note about this implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike `str-string`, which explicitly defined every needed method in its module
    body, `str-bytestring` provides `null` and `singleton` simply by reexporting all
    of the entities from `Data.ByteString.Char8` (which are appropriately monomorphic).
    We've cleverly picked our names to abide by the existing naming conventions of
    existing string packages!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our implementations of `splits` and `parts` are substantially more optimized
    than if we had done a straight up transcription of the consing and unconsing from
    the original `String` implementation. I often hear people say that `String` and
    `ByteString` have very different performance characteristics, and thus you shouldn't
    mix them up in the same implementation. I think this example shows that as long
    as you have sufficiently high-level operations on your strings, these performance
    changes smooth out in the end; and there is still a decent chunk of code that
    can be reused across implementations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To instantiate `regex-indef` with `bytestring-string:Str`, we once again modify
    the dependency in `main`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to stick an `{-# LANGUAGE OverloadedStrings #-}` pragma so that
    `"acc"` gets interpreted as a `ByteString` (unfortunately, the `bkp` file format
    only supports language pragmas that get applied to all modules defined; so put
    this pragma at the top of the file). But otherwise, everything works as it should!'
  prefs: []
  type: TYPE_NORMAL
- en: Using both instantiations at once
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There is nothing stopping us from using both instantiations of `regex-indef`
    at the same time, simply by uncommenting both `dependency` declarations, except
    that the module names provided by each dependency conflict with each other and
    are thus ambiguous. Backpack files thus provide a *renaming* syntax for modules
    which let you give each exported module a different name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'How should we modify `Main` to run our regex on both a `String` and a `ByteString`?
    But is `Regex.String.Reg` the same as `Regex.ByteString.Reg`? A quick query to
    the compiler will reveal that they are *not* the same. The reason for this is
    Backpack''s type identity rule: the identity of all types defined in a unit depends
    on how *all* signatures are instantiated, even if the type doesn''t actually depend
    on any types from the signature. If we want there to be only one `Reg` type, we
    will have to extract it from `reg-indef` and give it its own unit, with *no* signatures.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After the refactoring, here is the full final program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: And beyond!
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Read on to the next blog post, [Try Backpack: Cabal packages](http://blog.ezyang.com/2017/01/try-backpack-cabal-packages/),
    where I tell you how to take this prototype in a `bkp` file, and scale it up into
    a set of Cabal packages.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Postscript.** If you are feeling adventurous, try further parametrizing `regex-types`
    so that it no longer hard-codes `Char` as the element type, but some arbitrary
    element type `Elem`. It may be useful to know that you can instantiate multiple
    signatures using the syntax `dependency regex-indef[Str=str-string:Str,Elem=str-string:Elem]`
    and that if you depend on a package with a signature, you must thread the signature
    through using the syntax `dependency regex-types[Elem=<Elem>]`. If this sounds
    user-unfriendly, it is! That is why in the Cabal package universe, instantiation
    is done *implicitly*, using mix-in linking.'
  prefs: []
  type: TYPE_NORMAL
