- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-07-01 18:17:03'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: 'Left-recursive parsing of Haskell imports and declarations : ezyang’s blog'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[http://blog.ezyang.com/2016/12/left-recursive-parsing-of-haskell-imports-and-declarations/](http://blog.ezyang.com/2016/12/left-recursive-parsing-of-haskell-imports-and-declarations/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Suppose that you want to parse a list separated by newlines, but you want to
    automatically ignore extra newlines (just in the same way that `import` declarations
    in a Haskell file can be separated by one or more newlines.) Historically, GHC
    has used a curious grammar to perform this parse (here, semicolons represent newlines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'It takes a bit of squinting, but what this grammar does is accept a list of
    decls, interspersed with one or more semicolons, with zero or more leading/trailing
    semicolons. For example, `;decl;;decl;` parses as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: (Rule 3 gets exercised if there is no leading semicolon.)
  prefs: []
  type: TYPE_NORMAL
- en: 'This grammar has two virtues: first, it only requires a single state, which
    reduces the size of the parser; second, it is left-recursive, which means that
    an LALR parser (like Happy) can parse it in constant stack space.'
  prefs: []
  type: TYPE_NORMAL
- en: This code worked quite well for a long time, but it finally fell over in complexity
    when we added annotations to GHC. Annotations are a feature which track the locations
    of all keywords/punctuation/whitespace in source code, so that we byte-for-byte
    can reconstruct the source code from the abstract syntax tree (normally, this
    formatting information is lost at abstract syntax). With annotations, we needed
    to save information about each semicolon; for reasons that I don't quite understand,
    we were expending considerable effort to associate each semicolon with preceding
    declaration (leading semicolons were propagated up to the enclosing element.)
  prefs: []
  type: TYPE_NORMAL
- en: 'This lead to some very disgusting parser code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Can you tell what this does?! It took me a while to understand what the code
    is doing: the null test is to check if there is a *preceding* element we can attach
    the semicolon annotation to: if there is none, we propagate the semicolons up
    to the top level.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The crux of the issue was that, once annotations were added, **the grammar
    did not match the logical structure of the syntax tree.** That''s bad. Let''s
    make them match up. Here are a few constraints:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The leading semicolons are associated with the *enclosing* AST element. So
    we want to parse them once at the very beginning, and then not bother with them
    in the recursive rule. Call the rule to parse zero or more semicolons `semis`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If there are duplicate semicolons, we want to parse them all at once, and then
    associate them with the preceding declarations. So we also need a rule to parse
    one or more semicolons, which we will call `semis1`; then when we parse a single
    declaration, we want to parse it as `decl semis1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we can build up our parser in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve taken care not to introduce any shift-reduce conflicts. It was actually
    a bit non-obvious how to make this happen, because in Haskell source files, we
    need to parse a list of import declarations (`importdecl`), followed by a list
    of top-level declarations (`topdecl`). It''s a bit difficult to define the grammar
    for these two lists without introducing a shift-reduce conflict, but this seems
    to work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It looks so simple, but there are a lot of plausible looking alternatives which
    introduce shift/reduce conflicts. There's an important meta-lesson here, which
    is that when trying to work out how to do something like this, it is best to experiment
    with on a smaller grammar, where re-checking is instantaneous (happy takes quite
    a bit of time to process all of GHC, which made the edit-recompile cycle a bit
    miserable.)
  prefs: []
  type: TYPE_NORMAL
- en: I'd love to know if there's an even simpler way to do this, or if I've made
    a mistake and changed the set of languages I accept. Let me know in the comments.
    I've attached below a simple Happy grammar that you can play around with (build
    with `happy filename.y; ghc --make filename.hs`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
