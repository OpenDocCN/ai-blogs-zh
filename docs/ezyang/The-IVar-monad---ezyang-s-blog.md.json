["```\nimport Data.IORef\n\nnewtype R a = R { runR :: IO (IORef a) }\n\ninstance Functor R where\n  fmap f m = R $ do xref <- runR m\n                    x <- readIORef xref\n                    newIORef (f x)\n\ninstance Monad R where\n  return x = R (newIORef x)\n  m >>= f\n    = R $ do xref <- runR m\n             x <- readIORef xref\n             runR (f x)\n\n```", "```\nnewtype S a = S { runS :: IO (IORef (Maybe a)) }\n\ninstance Monad S where\n  return x = S (newIORef (Just x))\n  m >>= f\n    = S $ do xref <- runS m\n             mx <- readIORef xref\n             case mx of\n               Just x -> runS (f x)\n               Nothing -> ???\n\n```", "```\ndata IVarContents a =\n    Empty\n  | Blocking [a -> IO ()]\n  | Full a\n\nnewtype T a = T { runT :: IO (IORef (IVarContents a)) }\n\n```", "```\ninstance Monad T where\n  return x = T (newIORef (Full x))\n  m >>= f\n    = T $ do xref <- runT m\n             mx <- readIORef xref\n             r <- newIORef Empty\n             let callback x = runT (f x >>= fillIVar r) >> return ()\n             case mx of\n               Full x      -> callback x\n               Empty       -> writeIORef xref (Blocking [callback])\n               Blocking cs -> writeIORef xref (Blocking (callback:cs))\n             return r\n\n```", "```\nfillIVar :: IORef (IVarContents a) -> a -> T ()\nfillIVar ref x = T $ do\n  r <- readIORef ref\n  writeIORef ref (Full x)\n  case r of\n    Empty -> newIORef (Full ())\n    Blocking cs -> mapM_ ($x) cs >> newIORef (Full ())\n    Full _ -> error \"fillIVar: Cannot write twice\"\n\n```"]