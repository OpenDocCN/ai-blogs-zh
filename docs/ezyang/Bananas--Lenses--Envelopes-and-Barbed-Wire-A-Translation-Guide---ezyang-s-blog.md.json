["```\n Bifunctor t => t a b\n Functor f => f a\n [a]\n (d, d')\n Either d d'\n Identity\n Const d\n (Functor f, Functor g) => g (f a)\n (Bifunctor t, Functor f, Functor g) => Lift t f g a\n ()\n\n```", "```\n bimap f g :: Bifunctor t => t a a' -> t b b'\n fmap f :: Functor f => f a -> f b\n f *** g :: (a, a') -> (b, b')\n    where f *** g = \\(x, x') -> (f x, g x')\n fst :: (a, b) -> a\n snd :: (a, b) -> b\n f &&& g :: a -> (b, b')        -- a = a'\n    where f &&& g = \\x -> (f x, g x)\n double :: a -> (a, a)\n    where double x = (x, x)\n asum f g :: Either a a' -> Either b b'\n    where asum f g (Left x)  = Left (f x)\n          asum f g (Right y) = Right (g y)\n Left :: a -> Either a b\n Right :: b -> Either a b\n either f g :: Either a a' -> b        -- b = b'\n extract x :: a\n    where extract (Left x) = x\n          extract (Right x) = x\n (f --> g) h = g . h . f\n    (-->) :: (a' -> a) -> (b -> b') -> (a -> b) -> a' -> b'\n (g <-- f) h = g . h . f\n    (<--) :: (b -> b') -> (a' -> a) -> (a -> b) -> a' -> b'\n (g <-*- f) h = g . fmap h . f\n    (<-*-) :: Functor f => (f b -> b') -> (a' -> f a) -> (a -> b) -> a' -> b'\n id f :: a -> b\n const id f :: a -> a\n (fmap . fmap) x\n const ()\n fix f\n\n```", "```\neither (f &&& g) (h &&& j) = (either f h) &&& (either g j)\n\n```"]