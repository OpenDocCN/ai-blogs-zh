["```\nINFO_TABLE_RET(stg_maskUninterruptiblezh_ret, RET_SMALL, W_ info_ptr)\n    return (P_ ret)\n{\n    StgTSO_flags(CurrentTSO) =\n       %lobits32(\n        (TO_W_(StgTSO_flags(CurrentTSO))\n          | TSO_BLOCKEX)\n          & ~TSO_INTERRUPTIBLE\n       );\n\n    return (ret);\n}\n\n```", "```\nezyang@javelin:~/Dev/ghc-clean/rts$ grep -R INFO_TABLE_RET ../compiler/\n../compiler/cmm/CmmParse.y:INFO_TABLE_RET ( label, FRAME_TYPE, info_ptr, field1, ..., fieldN )\n../compiler/cmm/CmmParse.y:        'INFO_TABLE_RET'{ L _ (CmmT_INFO_TABLE_RET) }\n../compiler/cmm/CmmParse.y:        | 'INFO_TABLE_RET' '(' NAME ',' INT ')'\n../compiler/cmm/CmmParse.y:        | 'INFO_TABLE_RET' '(' NAME ',' INT ',' formals0 ')'\n../compiler/cmm/CmmParse.y:-- is.  That is, for an INFO_TABLE_RET we want the return convention,\n../compiler/cmm/CmmLex.x:  | CmmT_INFO_TABLE_RET\n../compiler/cmm/CmmLex.x:   ( \"INFO_TABLE_RET\",     CmmT_INFO_TABLE_RET ),\n\n```", "```\nezyang@javelin:~/Dev/ghc-clean/rts$ find ../compiler -name *.y\n../compiler/cmm/CmmParse.y\n../compiler/parser/ParserCore.y\n\n```", "```\nmaybe_conv :: { Convention }\n           : {- empty -}        { NativeNodeCall }\n           | 'return'           { NativeReturn }\n\n```", "```\nstmt    :: { CmmParse () }\n        : ';'                                   { return () }\n...\n        | 'goto' NAME ';'\n                { do l <- lookupLabel $2; emit (mkBranch l) }\n        | 'return' '(' exprs0 ')' ';'\n                { doReturn $3 }\n\n```", "```\ncmmproc :: { CmmParse () }\n        : info maybe_conv maybe_formals maybe_body\n                { do ((entry_ret_label, info, stk_formals, formals), agraph) <-\n                       getCodeR $ loopDecls $ do {\n                         (entry_ret_label, info, stk_formals) <- $1;\n                         formals <- sequence (fromMaybe [] $3);\n                         $4;\n                         return (entry_ret_label, info, stk_formals, formals) }\n                     let do_layout = isJust $3\n                     code (emitProcWithStackFrame $2 info\n                                entry_ret_label stk_formals formals agraph\n                                do_layout ) }\n\n```", "```\nA stack frame is written like this:\n\nINFO_TABLE_RET ( label, FRAME_TYPE, info_ptr, field1, ..., fieldN )\n               return ( arg1, ..., argM )\n{\n  ... code ...\n}\n\nwhere field1 ... fieldN are the fields of the stack frame (with types)\narg1...argN are the values returned to the stack frame (with types).\nThe return values are assumed to be passed according to the\nNativeReturn convention.\n\n```", "```\nGnam.$WKST =\n    \\r [tpl_sl4 tpl_sl6]\n        case tpl_sl4 of tpl_sl8 {\n          __DEFAULT ->\n              case tpl_sl6 of tpl_sl9 {\n                __DEFAULT -> Gnam.KST [tpl_sl8 tpl_sl9];\n              };\n        };\n\n```", "```\nezyang@javelin:~/Dev/ghc-clean/compiler$ grep -R ddump-stg .\n./main/DynFlags.hs:  , Flag \"ddump-stg\"               (setDumpFlag Opt_D_dump_stg)\nezyang@javelin:~/Dev/ghc-clean/compiler$ grep -R Opt_D_dump_stg .\n./main/DynFlags.hs:   | Opt_D_dump_stg\n./main/DynFlags.hs:  , Flag \"ddump-stg\"               (setDumpFlag Opt_D_dump_stg)\n./simplStg/SimplStg.lhs:        ; dumpIfSet_dyn dflags Opt_D_dump_stg \"STG syntax:\"\n\n```", "```\n; dumpIfSet_dyn dflags Opt_D_dump_stg \"STG syntax:\"\n                (pprStgBindings un_binds)\n\n```", "```\npprStgExpr (StgLam bndrs body)\n  = sep [ char '\\\\' <+> ppr_list (map (pprBndr LambdaBind) bndrs)\n            <+> ptext (sLit \"->\"),\n         pprStgExpr body ]\n  where ppr_list = brackets . fsep . punctuate comma\n\n...\n\n-- general case\npprStgRhs (StgRhsClosure cc bi free_vars upd_flag srt args body)\n  = sdocWithDynFlags $ \\dflags ->\n    hang (hsep [if gopt Opt_SccProfilingOn dflags then ppr cc else empty,\n                pp_binder_info bi,\n                ifPprDebug (brackets (interppSP free_vars)),\n                char '\\\\' <> ppr upd_flag, pprMaybeSRT srt, brackets (interppSP args)])\n         4 (ppr body)\n\n```", "```\nStgLam is used *only* during CoreToStg's work. Before CoreToStg has\nfinished it encodes (\\x -> e) as (let f = \\x -> e in f)\n\n```", "```\ndata UpdateFlag = ReEntrant | Updatable | SingleEntry\n\ninstance Outputable UpdateFlag where\n    ppr u = char $ case u of\n                       ReEntrant   -> 'r'\n                       Updatable   -> 'u'\n                       SingleEntry -> 's'\n\n```"]