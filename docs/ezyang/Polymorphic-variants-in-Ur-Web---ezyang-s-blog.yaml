- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-07-01 18:17:29'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: 'Polymorphic variants in Ur/Web : ezyang’s blog'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[http://blog.ezyang.com/2012/07/polymorphic-variants-in-urweb/](http://blog.ezyang.com/2012/07/polymorphic-variants-in-urweb/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This document explains how **polymorphic variants** in [Ur/Web](http://www.impredicative.com/ur/)
    work. It was written because the [official tutorial](http://www.impredicative.com/ur/tutorial/)
    has no mention of them, the manual only devotes a paragraph to the topic, and
    there are some useful tricks for dealing with them that I picked up while wrangling
    with them in [Logitext](http://logitext.mit.edu/main).
  prefs: []
  type: TYPE_NORMAL
- en: What are polymorphic variants?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Polymorphic variants may be [familiar to OCaml users](http://caml.inria.fr/pub/docs/manual-ocaml/manual006.html):
    they permit you to use the tags of variants in multiple types, and not just in
    the original algebraic data type a constructor was defined in. Instead having
    to keep names unique:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can just reuse them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This is extremely convenient if you have a lot of constructors which you want
    to share between multiple logical types. Unfortunately, they have a number of
    [nasty](http://t-a-w.blogspot.com/2006/05/variant-types-in-ocaml-suck.html) [effects](https://ocaml.janestreet.com/?q=node/99),
    largely stemming from the fact that they introduce subtyping to the language.
    In Ur, this inherent subtyping is modulated by the same row types that power Ur’s
    record system, so handling polymorphic variants is quite like handling records,
    and both are based off of Ur/Web’s type-level records.
  prefs: []
  type: TYPE_NORMAL
- en: How do I make a polymorphic variant?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make a polymorphic variant type, instead of applying the `$` operator, instead
    apply the `variant` to a type-level record. So:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'generates a record with two fields, `A` containing an `int` and `B` containing
    a `bool`, whereas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: generates a variant with two constructors, `A` containing just an `int`, or
    `B` containing just a `bool`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make a polymorphic variant value, use the `make` function, which requires
    a label (indicating the constructor) and the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Technically, during the construction of a polymorphic variant, you also need
    to know what the full set of constructors this value will be used with are. Normally
    Ur/Web will infer this for you, but this is an important restriction which will
    affect code that operates on variants. The full signature of `make` is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The function of `nm` and `t` should be self-evident, and `ts` is the type-level
    record for the rest of the values in the variant, concatenated with `[nm = t]`
    to produce a type-level record which is guaranteed to contain `nm`.
  prefs: []
  type: TYPE_NORMAL
- en: How do I destruct a polymorphic variant?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Use the `match` function, which takes a variant and a record of functions which
    indicate how to process each possible constructor of the variant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Indeed, the variant and the record use the *same* type-level record, though
    the types of the record are a little different, as seen in the type of match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: What other operations can I perform on variants?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`make` and `match` are the only primitives you need: everything else can derived.
    However, the [meta](http://hg.impredicative.com/meta/) library has a `Variant`
    module which contains of useful derived functions for operating with variants.
    For example, this pair of functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Allow you to use variants as labels, to project and edit values from homogeneously
    typed records. The signatures are not too difficult to read: `r` is the type-level
    record which defines the variant, `t` is the type of the homogeneous record, `folder
    r` is a folder for the record (which usually will get inferred), `$(mapU t r)`
    is the type of a homogeneous record (we didn’t write `$r` because that would be
    a record containing only unit) and `variant (mapU {} r)` is the variant serving
    as a “label”. Here are some example uses of some of the simpler functions in this
    library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: What does destrR do?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This function has a somewhat formidable type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'But really, it’s just a more general `match`. `match` can easily be implemented
    in terms of `destrR`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`destrR` affords more flexibility when the record is not quite a function,
    but a record containing a function, or a type class, or even if the variant is
    the function and the record the data.'
  prefs: []
  type: TYPE_NORMAL
- en: Is there a more concise way to match over multiple constructors?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Polymorphic variants frequently have a lot of constructors, all of which look
    basically the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Filling out records to `match` against quickly gets old, especially if the
    functionality for any two constructors with the same type of data is the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Adam Chlipala and I developed a nice method for reducing this boilerplate by
    abusing *local type classes*, which allow us to lean of Ur/Web’s inference engine
    to automatically fill in the function to handle an element of a particular type.
    Here is that recursive traversal again, using our new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: For every “type” in the variant, you write a `declareCase` which takes that
    type and reduces it to the desired return type. (You also get, as the first constructor,
    a constructor function to create the original constructor; e.g. `declareCase (fn
    f x => f x)` is the identity transformation. Then you run `typeCase` and watch
    the magic happen. There are more detailed usage instructions in [variant.urs](http://hg.impredicative.com/meta/file/f55f66c6fdee/variant.urs).
  prefs: []
  type: TYPE_NORMAL
- en: How do I make the type of my variant bigger?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When writing metaprograms that create variant types, a common problem is that
    the variant you just created is too narrow: that is, the `ts` in `variant ts`
    doesn’t have enough entries in it. This is especially a problem when `ts` is the
    record you are folding over. Consider a simple example where we would like to
    write this function, which generates a record of constructors for each constructor
    of the variant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Ur/Web is not clever enough to figure out the naive approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: because it has no idea that `nm` is a member of the type-level record `ts` (Ur/Web
    doesn’t directly have an encoding of field inclusion.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The way to fix this problem is to use a trick that shows up again and again
    in variant metaprograms: make the accumulator polymorphic in the fields that are
    already processed. It is the same trick that is employed in value level programs,
    when you reverse a list by `foldr` by observing that you want to make the accumulator
    a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`accum` is the type of the accumulator, and we can see it has a new type argument
    `s :: {Type}`. This argument is concatenated with the fields that are to be processed
    `r` and the current field `nm` in order to provide the full set of fields `ts`.
    During a fold over a record like `[A = int, B = bool, C = string]`, we see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`r` builds up fields as usual in a fold, but `s` builds up its fields in reverse,
    because, like list reverse, `s` is not determined until we’ve folded over the
    entire structure, and now evaluate the pile of type functions outside-in. Thus,
    it’s easy to see `k [[nm = v] ++ s]` will always have the correct type.'
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Polymorphic variants in Ur/Web are quite useful, and avoid many of the problems
    associated with unrestricted subtyping. Logitext wasn’t originally intending on
    using polymorphic variants, but we adopted them when they were found to be the
    most reliable method by which we could quickly implement JSON serialization via
    metaprogramming, and we’ve come to appreciate their metaprogrammability in a variety
    of other contexts too. Probably their biggest downside over traditional algebraic
    data types is the lack of recursion, but that too can be simulated by manually
    implementing the mu operator using Ur/Web’s module system. I hope this tutorial
    has given you enough meat to use polymorphic variants on your own, and maybe do
    a little metaprogramming with them too.
  prefs: []
  type: TYPE_NORMAL
