- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-07-01 18:18:09'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: 'Keyword arguments in Haskell : ezyang’s blog'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[http://blog.ezyang.com/2010/09/keyword-arguments-in-haskell/](http://blog.ezyang.com/2010/09/keyword-arguments-in-haskell/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Keyword arguments in Haskell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Keyword arguments are generally considered a good thing by language designers:
    positional arguments are prone to errors of transposition, and it’s absolutely
    no fun trying to guess what the `37` that is the third argument of a function
    *actually* means. Python is one language that makes extensive use of keyword arguments;
    they have the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: Functions are permitted to be a mix of positional and keyword arguments (a nod
    to the compactness of positional arguments),
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Keywords are local to any given function; you can reuse a named function argument
    for another function,
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Python 3.0, you can force certain arguments to *only* be specifiable with
    a keyword.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Does Haskell have keyword arguments? In many ways, they’re much less necessary
    due to the static type system: if you accidentally interpose an `Int` and `Bool`
    your compiler will let you know about it. The type signature guides you!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Still, if we were to insist (perhaps our function took many arguments of the
    same type), one possibility is to pass a record data type in as the sole argument,
    but this is a little different than Python keyword arguments in the following
    ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a strict delineation between positional and keywords: either you can
    specify your record entirely with keywords or entirely with positional arguments,
    but you can’t do both,'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Record fields go into the global namespace, so you have to prefix/suffix them
    with some unique identifier, and
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Even with named records, a user can still choose to construct the record without
    specifying keyword arguments. For large argument lists, this is not as much of
    an issue, but for short argument lists, the temptation is great.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I find issue two to be the reason why I don’t really employ this trick; I would
    find it quite annoying to have to make a data structure for every function that
    I wanted to use named arguments with.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’d like to suggest another trick to simulate named arguments: use newtypes!
    Consider this undertyped function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can convert it to use newtypes like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike the usual use of newtypes, our newtypes are extremely short-lived: they
    last just long enough to get into the body of `renderBox` and then they are pattern
    matched to oblivion: the function body can rely on good local variable names to
    do the rest. But it still manages to achieve the goals of keyword arguments: any
    call to `renderBox` makes it crystal clear what each integer means. We also maintain
    the following good properties:'
  prefs: []
  type: TYPE_NORMAL
- en: If the type already says all you need to say about an argument, there’s no need
    to newtype it again. Thus, you can have a mix of regular and newtype arguments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Newtypes can be reused. Even further, they are only to be reused when the semantic
    content of their insides is the same, which encourages good naming practices.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The user is forced to do the newtype wrapping: there’s no way around it. If
    you publish smart constructors instead of the usual constructors, you can factor
    out validation too.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Newtypes are so versatile!
  prefs: []
  type: TYPE_NORMAL
