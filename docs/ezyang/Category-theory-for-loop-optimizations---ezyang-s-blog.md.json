["```\n(0 :: numClusters, *) { j =>\n  val weightedPoints = sumRowsIf(0,m){i => c(i) == j}{i => x(i)};\n  val points = c.count(_ == j);\n  val d = if (points == 0) 1 else points\n  weightedPoints / d\n}\n\n```", "```\nval allWP = hashreduce(0,m)(i => c(i), i => x(i), _ + _)\nval allP = hashreduce(0,m)(i => c(i), i => 1, _ + _)\n(0::numClusters, *) { j =>\n    val weightedPoints = allWP(j);\n    val points = allP(j);\n    val d = if (points == 0) 1 else points\n    return weightedpoints / d\n}\n\n```", "```\ntabulate (\\j ->\n  let weightedPoints = fold plus . filter (\\i -> c[i] == j) $ x\n      points = fold inc . filter (\\i -> c[i] == j) $ x\n  in divide (weightedPoints, points)\n)\n\n```", "```\ntabulate (\\j -> divide . fold (plus * inc) . filter (\\i -> c[i] == j) $ x)\n\n```", "```\ntabulate (\\j -> divide . fold (plus * inc) . index j . bucket c $ x)\n\n```", "```\ntabulate (\\j -> index j . fmap (divide . fold (plus * inc)) . bucket c $ x)\n\n```", "```\nfmap (divide . fold (plus * inc)) . bucket c $ x\n\n```", "```\nfmap divide . hashreduce (plus * inc) c $ x\n\n```"]