["```\n> import Prelude hiding (break, catch)\n> import Control.Monad\n> import Control.Monad.Trans\n\n```", "```\n> newtype ExT e m a = ExT{unExT :: m (Either e a)}\n>\n> instance Monad m => Monad (ExT e m) where\n>     return  = ExT . return . Right\n>     m >>= f = ExT $ unExT m >>= either (return . Left) (unExT . f)\n>\n> instance MonadTrans (ExT e) where\n>     lift m = ExT $ m >>= return . Right\n>\n> instance MonadIO m => MonadIO (ExT e m) where\n>     liftIO m = ExT $ liftIO m >>= return . Right\n>\n> raise :: Monad m => e -> ExT e m a\n> raise = ExT . return . Left\n>\n> catch :: Monad m => ExT e m a -> (e -> ExT e' m a) -> ExT e' m a\n> catch m h = ExT $ unExT m >>= either (unExT . h) (return . Right)\n>\n> runExT :: Monad m => ExT e m a -> m a\n> runExT m = unExT m >>= either (const $ fail \"Unhandled exc\") return\n\n```", "```\n> data BC = Break | Cont\n>\n> break, continue :: Monad m => ExT BC m a\n> break    = raise Break\n> continue = raise Cont\n\n```", "```\n> for_in :: Monad m => [a] -> (a -> ExT BC m ()) -> m ()\n> for_in xs f = runExT $ mapM_ iter xs `catch` hbreak\n>  where\n>  iter x = catch (f x) hcont\n>  hcont  Cont  = return ()     -- handle Cont, re-raise Break\n>  hcont  e     = raise e\n>  hbreak Break = return ()\n>  hbreak Cont  = return ()     -- Shouldn't happen actually\n\n```", "```\n> loopLookForIt1 :: IO ()\n> loopLookForIt1 =\n>     for_in [0..100] $ \\x -> do\n>         when (x `mod` 3 == 1) $ continue\n>         when (x `div` 17 == 2) $ break\n>         lift $ print x\n\n```", "```\n> tf1 = loopLookForIt1 :: IO ()\n\n```", "```\n> data BCN = BCN BC Int                 -- Add the level of breaking\n\n```", "```\n> breakN    = raise . BCN Break\n> continueN = raise . BCN Cont\n\n```", "```\n> for_inN :: Monad m => [a] -> (a -> ExT BCN m ()) -> ExT BCN m ()\n> for_inN xs f = mapM_ iter xs `catch` hbreak\n>  where\n>  iter x = catch (f x) hcont\n>  hcont  (BCN Cont 0)  = return ()     -- handle Cont, re-raise Break\n>  hcont  e             = raise e\n>  -- If the exception is for a parent, re-raise it, decrementing its level\n>  hbreak (BCN Break 0) = return ()\n>  hbreak (BCN Cont 0)  = return ()     -- Shouldn't happen actually\n>  hbreak (BCN exc n)   = raise (BCN exc (n-1))\n\n```", "```\n> loopLookForItN :: ExT BCN IO ()\n> loopLookForItN =\n>     for_inN [0..100] $ \\x -> do\n>         when (x `mod` 3 == 1) $ continueN 0\n>         when (x `div` 17 == 2) $ breakN 0\n>         lift $ print x\n>\n> tfN = runExT loopLookForItN :: IO ()\n\n```", "```\n> loopBreakOuter1 :: ExT BCN IO ()\n> loopBreakOuter1 =\n>     for_inN [1,2,3] $ \\x -> do\n>         lift $ print x\n>         for_inN [4,5,6] $ \\y -> do\n>             lift $ print y\n>             when (y == 4) $ continueN 0\n>             when (x == 1) $ breakN 0\n>             when (x == 3) $ breakN 1\n>             when (y == 5) $ continueN 1\n>             breakN 1\n>         lift $ print x\n>\n> tbN1 = runExT loopBreakOuter1 :: IO ()\n\n```", "```\n> loopBreakOuterS1 :: IO ()\n> loopBreakOuterS1 =\n>     for_in [1,2,3] $ \\x -> do\n>         liftIO $ print x\n>         for_in [4,5,6] $ \\y -> do\n>             liftIO $ print y\n>             when (y == 4) $ continue\n>             when (x == 1) $ break\n>             when (x == 3) $ lift $ break\n>             when (y == 5) $ lift $ continue\n>             lift $ break\n>         liftIO $ print x\n> tbS1 = loopBreakOuterS1 :: IO ()\n\n```"]