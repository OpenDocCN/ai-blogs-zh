["```\nc2EP:\n    _s28e::P64 = R2;\n    // Check if there is enough heap space\n    Hp = Hp + 40;\n    if (Hp > HpLim) goto c2ET; else goto c2ES;\nc2ET:\n    // If not enough space, GC\n    HpAlloc = 40;\n    R2 = _s28e::P64;\n    R1 = withEmpty_riC_static_closure;\n    call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;\nc2ES:\n    // Write a bunch of data to the heap\n    I64[Hp - 32] = sat_s28f_info;\n    _c2EG::P64 = Hp - 32;\n    I64[Hp - 16] = :_con_info;\n    P64[Hp - 8] = _c2EG::P64;\n    P64[Hp] = _s28e::P64;\n    _c2EO::P64 = Hp - 14;\n    R1 = _c2EO::P64;\n    // No stack updates this time\n    // Jump to the continuation\n    call (P64[Sp])(R1) args: 8, res: 0, upd: 8;\n\n```", "```\nallocDynClosureCmm info_tbl args_offsets\n  = do  { virt_hp <- getVirtHp\n        ; let rep = cit_rep info_tbl -- cit = c info table\n              info_offset = virt_hp + 1 -- virtual heap offset of first word of new object\n              info_ptr = CmmLit (CmmLabel (cit_lbl info_tbl))\n        ; base <- getHpRelOffset (virt_hp + 1)\n        ; emitSetDynHdr base info_ptr\n        ; let (args, offsets) = unzip args_offsets\n        ; hpStore base args offsets\n        ; setVirtHp (virt_hp + heapClosureSize rep)\n        ; getHpRelOffset info_offset\n        }\n\n```", "```\nnewtype FCode a = FCode (CgInfoDownwards -> CgState -> (# a, CgState #))\n\ndata CgState\n  = MkCgState { ...\n     cgs_hp_usg  :: HeapUsage,\n     ... }\n\ndata HeapUsage =\n  HeapUsage {\n        virtHp :: VirtualHpOffset, -- Virtual offset of highest-allocated word\n                                   --   Incremented whenever we allocate\n        realHp :: VirtualHpOffset  -- realHp: Virtual offset of real heap ptr\n                                   --   Used in instruction addressing modes\n  }\n\n```", "```\nc2EP:\n    _s28e::P64 = R2;\n    // Check if there is enough heap space\n    // virtHp = 0; realHp = 0\n    Hp = Hp + 40;\n    // virtHp = 0; realHp = 40\n    if (Hp > HpLim) goto c2ET; else goto c2ES;\nc2ET:\n    // If not enough space, GC\n    HpAlloc = 40;\n    R2 = _s28e::P64;\n    R1 = withEmpty_riC_static_closure;\n    call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;\nc2ES:\n    // Write a bunch of data to the heap\n    // First closure\n    // virtHp = 0; realHp = 40\n    I64[Hp - 32] = sat_s28f_info;\n    _c2EG::P64 = Hp - 32;\n    // virtHp = 8; realHp = 40\n    I64[Hp - 16] = :_con_info;\n    P64[Hp - 8] = _c2EG::P64;\n    P64[Hp] = _s28e::P64;\n    _c2EO::P64 = Hp - 14;\n    // virtHp = 32; realHp = 40\n    R1 = _c2EO::P64;\n    // No stack updates this time\n    // Jump to the continuation\n    call (P64[Sp])(R1) args: 8, res: 0, upd: 8;\n\n```", "```\nheapCheck :: Bool -> Bool -> CmmAGraph -> FCode a -> FCode a\nheapCheck checkStack checkYield do_gc code\n  = getHeapUsage $ \\ hpHw ->\n\n```", "```\n-- 'getHeapUsage' applies a function to the amount of heap that it uses.\n-- It initialises the heap usage to zeros, and passes on an unchanged\n-- heap usage.\n--\n-- It is usually a prelude to performing a GC check, so everything must\n-- be in a tidy and consistent state.\n--\n-- Note the slightly subtle fixed point behaviour needed here\n\ngetHeapUsage :: (VirtualHpOffset -> FCode a) -> FCode a\ngetHeapUsage fcode\n  = do  { info_down <- getInfoDown\n        ; state <- getState\n        ; let   fstate_in = state { cgs_hp_usg  = initHpUsage }\n                (r, fstate_out) = doFCode (fcode hp_hw) info_down fstate_in\n                hp_hw = heapHWM (cgs_hp_usg fstate_out)        -- Loop here!\n\n        ; setState $ fstate_out { cgs_hp_usg = cgs_hp_usg state }\n        ; return r }\n\n```"]