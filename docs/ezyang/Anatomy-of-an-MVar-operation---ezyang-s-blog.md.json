["```\ntakeMVar :: MVar a -> IO a\ntakeMVar (MVar mvar#) = IO $ \\ s# -> takeMVar# mvar# s#\n\n```", "```\n(\"ptr\" info) = ccall lockClosure(mvar \"ptr\");\n\n```", "```\nEXTERN_INLINE StgInfoTable *lockClosure(StgClosure *p)\n{\n    StgWord info;\n    do {\n        nat i = 0;\n        do {\n            info = xchg((P_)(void *)&p->header.info, (W_)&stg_WHITEHOLE_info);\n            if (info != (W_)&stg_WHITEHOLE_info) return (StgInfoTable *)info;\n        } while (++i < SPIN_COUNT);\n        yieldThread();\n    } while (1);\n}\n\n```", "```\nif (info == stg_MVAR_CLEAN_info) {\n    ccall dirty_MVAR(BaseReg \"ptr\", mvar \"ptr\");\n}\n\n```", "```\n/* If the MVar is empty, put ourselves on its blocking queue,\n * and wait until we're woken up.\n */\nif (StgMVar_value(mvar) == stg_END_TSO_QUEUE_closure) {\n\n    // We want to put the heap check down here in the slow path,\n    // but be careful to unlock the closure before returning to\n    // the RTS if the check fails.\n    ALLOC_PRIM_WITH_CUSTOM_FAILURE\n        (SIZEOF_StgMVarTSOQueue,\n         unlockClosure(mvar, stg_MVAR_DIRTY_info);\n         GC_PRIM_P(stg_takeMVarzh, mvar));\n\n    q = Hp - SIZEOF_StgMVarTSOQueue + WDS(1);\n\n    SET_HDR(q, stg_MVAR_TSO_QUEUE_info, CCS_SYSTEM);\n    StgMVarTSOQueue_link(q) = END_TSO_QUEUE;\n    StgMVarTSOQueue_tso(q)  = CurrentTSO;\n\n    if (StgMVar_head(mvar) == stg_END_TSO_QUEUE_closure) {\n        StgMVar_head(mvar) = q;\n    } else {\n        StgMVarTSOQueue_link(StgMVar_tail(mvar)) = q;\n        ccall recordClosureMutated(MyCapability() \"ptr\",\n                                         StgMVar_tail(mvar));\n    }\n    StgTSO__link(CurrentTSO)       = q;\n    StgTSO_block_info(CurrentTSO)  = mvar;\n    StgTSO_why_blocked(CurrentTSO) = BlockedOnMVar::I16;\n    StgMVar_tail(mvar)             = q;\n\n    jump stg_block_takemvar(mvar);\n}\n\n```", "```\n/* we got the value... */\nval = StgMVar_value(mvar);\n\n```", "```\n    q = StgMVar_head(mvar);\nloop:\n    if (q == stg_END_TSO_QUEUE_closure) {\n        /* No further putMVars, MVar is now empty */\n        StgMVar_value(mvar) = stg_END_TSO_QUEUE_closure;\n        unlockClosure(mvar, stg_MVAR_DIRTY_info);\n        return (val);\n    }\n    if (StgHeader_info(q) == stg_IND_info ||\n        StgHeader_info(q) == stg_MSG_NULL_info) {\n        q = StgInd_indirectee(q);\n        goto loop;\n    }\n\n```", "```\n// There are putMVar(s) waiting... wake up the first thread on the queue\n\ntso = StgMVarTSOQueue_tso(q);\nStgMVar_head(mvar) = StgMVarTSOQueue_link(q);\nif (StgMVar_head(mvar) == stg_END_TSO_QUEUE_closure) {\n    StgMVar_tail(mvar) = stg_END_TSO_QUEUE_closure;\n}\n\nASSERT(StgTSO_why_blocked(tso) == BlockedOnMVar::I16); // note: I16 means this is a 16-bit integer\nASSERT(StgTSO_block_info(tso) == mvar);\n\n// actually perform the putMVar for the thread that we just woke up\nW_ stack;\nstack = StgTSO_stackobj(tso);\nPerformPut(stack, StgMVar_value(mvar));\n\n```", "```\n// indicate that the MVar operation has now completed.\nStgTSO__link(tso) = stg_END_TSO_QUEUE_closure;\n\n// no need to mark the TSO dirty, we have only written END_TSO_QUEUE.\n\nccall tryWakeupThread(MyCapability() \"ptr\", tso);\n\nunlockClosure(mvar, stg_MVAR_DIRTY_info);\nreturn (val);\n\n```", "```\ncommit f4692220c7cbdadaa633f50eb2b30b59edb30183\nAuthor: Simon Marlow <marlowsd@gmail.com>\nDate:   Thu Apr 1 09:16:05 2010 +0000\n\n    Change the representation of the MVar blocked queue\n\n    The list of threads blocked on an MVar is now represented as a list of\n    separately allocated objects rather than being linked through the TSOs\n    themselves.  This lets us remove a TSO from the list in O(1) time\n    rather than O(n) time, by marking the list object.  Removing this\n    linear component fixes some pathalogical performance cases where many\n    threads were blocked on an MVar and became unreachable simultaneously\n    (nofib/smp/threads007), or when sending an asynchronous exception to a\n    TSO in a long list of thread blocked on an MVar.\n\n    MVar performance has actually improved by a few percent as a result of\n    this change, slightly to my surprise.\n\n    This is the final cleanup in the sequence, which let me remove the old\n    way of waking up threads (unblockOne(), MSG_WAKEUP) in favour of the\n    new way (tryWakeupThread and MSG_TRY_WAKEUP, which is idempotent).  It\n    is now the case that only the Capability that owns a TSO may modify\n    its state (well, almost), and this simplifies various things.  More of\n    the RTS is based on message-passing between Capabilities now.\n\n```"]