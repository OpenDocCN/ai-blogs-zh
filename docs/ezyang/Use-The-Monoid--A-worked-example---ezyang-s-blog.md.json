["```\ngetPublicNames :: Module -> State (Map Name (Set ModuleName)) ()\ngetPublicNames (Module _ m _ _ (Just exports) _ _) = mapM_ handleExport exports\n    where handleExport x = case x of\n            EVar (UnQual n) -> add n\n            EAbs (UnQual n) -> add n\n            EThingAll (UnQual n) -> add n\n            EThingWith (UnQual n) cs -> add n >> mapM_ handleCName cs\n            _ -> return ()\n          handleCName x = case x of\n            VarName n -> add n\n            ConName n -> add n\n          add n = modify (Map.insertWith Set.union n (Set.singleton m))\ngetPublicNames _ = return ()\n\n```", "```\ndef getPublicNames(module, ret=None):\n    if not ret:\n        ret = defaultdict(set)\n    if module.exports is None:\n        return ret\n    for export in module.exports:\n        if isinstance(export, EVar) or \\\n           isinstance(export, EAbs) or \\\n           isinstance(export, EThingAll):\n            ret[export.name].add(module.name)\n        elif isinstance(export, EThingWith):\n            ret[export.name].add(module.name)\n            for cname in export.cnames:\n                ret[export.name].add(cname.name)\n    return ret\n\n```", "```\nnewtype SetMap k v = SetMap { unSetMap :: Map k (Set v) }\n\n```", "```\ninstance (Ord k, Ord v) => Monoid (SetMap k v) where\n    mempty = SetMap Map.empty\n    mappend (SetMap a) (SetMap b) = SetMap $ Map.unionWith Set.union a b\n    mconcat = SetMap . Map.unionsWith Set.union . map unSetMap\n\n```", "```\nsetMapSingleton :: (Ord k, Ord v) => k -> v -> SetMap k v\nsetMapSingleton k v = SetMap $ Map.singleton k (Set.singleton v)\n\n```", "```\ngetPublicNames :: Module -> Writer (SetMap Name ModuleName) ()\ngetPublicNames (Module _ m _ _ (Just exports) _ _) = mapM_ handleExport exports\n    where handleExport x = case x of\n            EVar (UnQual n) -> add n\n            EAbs (UnQual n) -> add n\n            EThingAll (UnQual n) -> add n\n            EThingWith (UnQual n) cs -> add n >> mapM_ handleCName cs\n            _ -> return ()\n          handleCName x = case x of\n            VarName n -> add n\n            ConName n -> add n\n          add n = tell (setMapSingleton n m) -- *\ngetPublicNames _ = return ()\n\n```", "```\n-- This operator is going into base soon, I swear!\n(<>) = mappend\n\ngetPublicNames :: Module -> SetMap Name ModuleName\ngetPublicNames (Module _ m _ _ (Just exports) _ _) = foldMap handleExport exports\n    where handleExport x = case x of\n            EVar (UnQual n) -> make n\n            EAbs (UnQual n) -> make n\n            EThingAll (UnQual n) -> make n\n            EThingWith (UnQual n) cs -> make n <> foldMap handleCName cs\n            _ -> mempty\n          handleCName x = case x of\n            VarName n -> make n\n            ConName n -> make n\n          make n = setMapSingleton n m\ngetPublicNames _ = mempty\n\n```"]