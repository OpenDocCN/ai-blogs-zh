- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-07-01 18:17:18'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: 'No grammar? No problem! : ezyang’s blog'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[http://blog.ezyang.com/2013/07/no-grammar-no-problem/](http://blog.ezyang.com/2013/07/no-grammar-no-problem/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: One day, you’re strolling along fields of code, when suddenly you spot a syntax
    construct that you don’t understand.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps you’d ask your desk-mate, who’d tell you in an instant what it was.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps your programming toolchain can tell you. (Perhaps the IDE would you
    mouse over the construct, or you’re using Coq which let’s you `Locate` custom
    notations.)
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps you’d pull up the manual (or, more likely, one of many tutorials) and
    scan through looking for the syntax construct in question.
  prefs: []
  type: TYPE_NORMAL
- en: But when all this fails, what is one to do? What if the code in question is
    written in an internal language for a compiler, whose details have changed since
    it was last documented, for which the documentation is out of date?
  prefs: []
  type: TYPE_NORMAL
- en: '*No problem.* As long as you’re willing to roll up your sleeves and take a
    look at the source code of the compiler in question, you can frequently resolve
    your question for less effort than it would have taken to look up the syntax in
    the manual (and it’s guaranteed to be up-to-date too!) The key is that modern
    compilers all use parser generators, and the input to these are essentially executable
    specifications.'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll give two examples from GHC. The first is from C--, GHC’s high-level assembly
    language. Consider this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Some aspects of this definition are familiar to someone who has written C before,
    but there are some mysterious bits. For example, what does the `return (P_ ret)`
    mean in the preamble?
  prefs: []
  type: TYPE_NORMAL
- en: 'The first order of business is to find the relevant file. When the code in
    question has very distinctive keywords (as this one does), a grep will often do
    the trick:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'File extensions can also be dead giveaways; GHC uses a parser generator named
    Happy, and the file extension of Happy files is `.y`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'From there, we can search the file for keywords or symbols (check for the string
    token name if a lexer is used; also, make sure to quote alphanumeric literals).
    A symbol can show up in multiple places, as it does for return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'and:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Guessing from the names of the productions and the contexts, it seems more
    likely that `maybe_conv` is the relevant production. It is used here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you really need to know *exactly* how it is lade out, you can go and
    checkout how `emitProcWithStackFrame` is implemented. Alternately, you might hope
    there is a useful comment in the source file which explains what is up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second example is for STG, which you can ask GHC to print out using `-ddump-stg`.
    Now, there is no parser for STG, so instead you’ll have to look at the *pretty-printer*.
    Not too difficult. Take this simple function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Some aspects are familiar. But what does the `\r` mean?
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, we have to find the relevant source file. Since STG is printed
    out only when we pass the `-ddump-stg` flag, a good start is to trace the flag
    through the source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s a good sign! Popping open `SimpleStg.lhs` gives us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: And the location of `pprStgBindings` (`compiler/stgSyn/StgSyn.lhs`) is in fact
    the ticket.
  prefs: []
  type: TYPE_NORMAL
- en: 'STG is pretty small, and as it turns out if you just do a quick scan of the
    file you’re likely to find what you need. But in case you don’t, you can still
    figure things out deliberately. Suppose we search for a quoted backslash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Which is it? As it turns out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `-ddump-stg` is post-CoreToSTG, we must be looking at `StgRhsClosure`,
    and `ppr upd_flag` looks like the ticket. `r` must be an `upd_flag`, whatever
    that is. An `UpdateFlag`, as it turns out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `r` indicates the function is re-entrant! (Of course, as for what that means,
    you’ll have to consult other documentation.)
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, in an ideal world, all of this would be documented. But even if it
    is not, there is no reason why you can’t help yourself. If your codebase is as
    nice as GHC’s, there will be plenty of breadcrumbs and comments to help you out.
    I hope this gives some insight into one possible thought process when you encounter
    something you don’t know, and don’t know how to learn. (Of course, sometimes it’s
    just best to ignore it!)
  prefs: []
  type: TYPE_NORMAL
