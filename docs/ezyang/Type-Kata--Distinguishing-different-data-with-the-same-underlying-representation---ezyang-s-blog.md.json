["```\nint Gia_Var2Lit( int Var, int fCompl )  { return Var + Var + fCompl; }\nint Gia_Lit2Var( int Lit )              { return Lit >> 1;           }\n\n```", "```\nint Gia_ManHashMux( Gia_Man_t * p, int iCtrl, int iData1, int iData0 )\n\n```", "```\nGia_Obj_t *  Gia_ObjFanin0( Gia_Obj_t * pObj );\n\n```", "```\n/* This macro takes a kernel virtual address -- an address that points above\n * KERNBASE, where the machine's maximum 256MB of physical memory is mapped --\n * and returns the corresponding physical address.  It panics if you pass it a\n * non-kernel virtual address.\n */\n#define PADDR(kva)                                          \\\n({                                                          \\\n        physaddr_t __m_kva = (physaddr_t) (kva);            \\\n        if (__m_kva < KERNBASE)                                     \\\n                panic(\"PADDR called with invalid kva %08lx\", __m_kva);\\\n        __m_kva - KERNBASE;                                 \\\n})\n\n/* This macro takes a physical address and returns the corresponding kernel\n * virtual address.  It panics if you pass an invalid physical address. */\n#define KADDR(pa)                                           \\\n({                                                          \\\n        physaddr_t __m_pa = (pa);                           \\\n        uint32_t __m_ppn = PPN(__m_pa);                             \\\n        if (__m_ppn >= npage)                                       \\\n                panic(\"KADDR called with invalid pa %08lx\", __m_pa);\\\n        (void*) (__m_pa + KERNBASE);                                \\\n})\n\n```", "```\nnewtype GiaLit = GiaLit { unGiaLit :: CInt }\nnewtype GiaVar = GiaVar { unGiaVar :: CInt }\n\n-- accessor functions omitted for brevity; they should be included\n\nnewtype CoGia_Obj_t = CoGia_Obj_t (Gia_Obj_t)\n\nnewtype PhysAddr a = PhysAddr (Ptr a)\nnewtype VirtualAddr a = VirtualAddr (Ptr a)\n\nnewtype RawBytestring = RawBytestring ByteString\n-- where e is some Encoding\nnewtype EncodedBytestring e = EncodedBytestring ByteString\n-- where n is some Normalization\nnewtype UTF8Bytestring n = UTF8Bytestring ByteString\ntype Text = UTF8Bytestring NFC\n\n-- where e is some endianness\nnewtype EndianByteStream e = EndianByteStream ByteString\n\nnewtype Tainted c = Tainted c\nnewtype Clean c = Clean c\n\n```"]