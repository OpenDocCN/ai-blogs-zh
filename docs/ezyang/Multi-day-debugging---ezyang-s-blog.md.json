["```\nmain = do tid <- block $ forkIO $ let x = x in x\n        killThread tid\n\n```", "```\n0x822a6e0 <stg_CAF_BLACKHOLE_info>:  jmp    0x822a620 <stg_BLACKHOLE_info>\n0x822a620 <stg_BLACKHOLE_info>:      mov    0x4(%esi),%eax\n0x822a623 <stg_BLACKHOLE_info+3>:    test   $0x3,%eax\n0x822a628 <stg_BLACKHOLE_info+8>:    jne    0x822a663 <stg_BLACKHOLE_info+67>\n0x822a62a <stg_BLACKHOLE_info+10>:   mov    (%eax),%ecx -- SEGFAULT!\n\n```", "```\ntype Malloc = CSize -> IO (Ptr ())\n\nforeign import ccall unsafe \"&malloc\" pmalloc:: FunPtr Malloc\nforeign import ccall unsafe \"dynamic\" callMalloc :: FunPtr Malloc -> Malloc\n\n```", "```\nhunk ./compiler/cmm/CmmOpt.hs 156\n-   where infn (CmmCallee fn cconv) = CmmCallee fn cconv\n+   where infn (CmmCallee fn cconv) = CmmCallee (inlineExpr u a fn) cconv\n\n```", "```\n{-# LANGUAGE ForeignFunctionInterface #-}\nmodule Main(main) where\n\nimport Foreign.C\n\nforeign import ccall safe \"foo\" foo :: CLLong -> CLLong\n-- Changing to unsafe causes stg_gc_l1 to not be generated\n-- Changing to IO causes slight cosmetic changes, but it's still wrong\n\nmain = print (foo 0)\n\n```", "```\nhunk ./compiler/cmm/CmmCallConv.hs 50\n-               (_,   GC)               -> getRegsWithNode\n+               (_,   GC)               -> allRegs\n\n```", "```\nimport Bagel\n\nmain = do\n    l <- getContents\n    length l `seq` putStr (sort l)\n\n```", "```\nmodule Bagel where\n-- a bastardized version of sort that still exhibits the bug\nsort :: Ord a => [a] -> [a]\nsort = mergeAll . sequences\n  where\n    sequences (a:xs) = compare a a `seq` []:sequences xs\n    sequences _ = []\n\n    mergeAll [x] = x\n    mergeAll xs  = mergeAll (mergePairs xs)\n\n    mergePairs (a:b:xs) = merge a b: mergePairs xs\n    mergePairs xs       = xs\n\n    merge (a:as') (b:bs') = compare a a `seq` merge as' as'\n    merge _ _ = []\n\n```", "```\n$ hexdump master-data\n0000000 7755 7755 7755 7755 7755 7755 7755 7755\n*\n000b040\n\n```"]