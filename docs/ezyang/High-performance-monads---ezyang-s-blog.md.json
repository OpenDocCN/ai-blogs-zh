["```\n> import Prelude hiding (Maybe(..), maybe)\n\n```", "```\n> data Id a = Id a\n> instance Monad Id where\n>     Id x >>= f = f x\n>     return = Id\n\n```", "```\n> data IdCPS r a = IdCPS { runIdCPS :: (a -> r) -> r }\n> instance Monad (IdCPS r) where\n>     IdCPS c >>= f =\n>         IdCPS (\\k -> c (\\a -> runIdCPS (f a) k))\n>     return x = IdCPS (\\k -> k x)\n\n```", "```\n> data Maybe a = Nothing | Just a\n> instance Monad Maybe where\n>     Just x >>= f = f x\n>     Nothing  >>= f = Nothing\n>     return = Just\n\n```", "```\n> newtype MaybeCPS r a = MaybeCPS { runMaybeCPS :: (a -> r) -> r -> r }\n> instance Monad (MaybeCPS r) where\n>     MaybeCPS c >>= f =\n>         MaybeCPS (\\sk fk -> c (\\a -> runMaybeCPS (f a) sk fk) fk)\n>     return x = MaybeCPS (\\sk fk -> sk x)\n\n```", "```\n> nothingCPS = MaybeCPS (\\_ fk -> fk)\n\n```", "```\n> justCPS x = MaybeCPS (\\sk _ -> sk x)\n\n```", "```\n> maybe :: Maybe a -> (a -> r) -> r -> r\n> maybe m sk fk =\n>     case m of\n>         Just a  -> sk a\n>         Nothing -> fk\n\n```", "```\n> monadicAddition mx my = do\n>   x <- mx\n>   y <- my\n>   return (x + y)\n> maybeTest    = maybe       (monadicAddition (Just 2)   Nothing)    print (return ())\n> maybeCPSTest = runMaybeCPS (monadicAddition (return 2) nothingCPS) print (return ())\n\n```", "```\n> data List a = Nil | Cons a (List a)\n> instance Monad List where\n>     Nil >>= _ = Nil\n>     Cons x xs >>= f = append (f x) (xs >>= f)\n>     return x = Cons x Nil\n> append Nil ys = ys\n> append (Cons x xs) ys = Cons x (append xs ys)\n\n```", "```\n> newtype LogicCPS r a = LogicCPS { runLogicCPS :: (a -> r -> r) -> r -> r }\n> instance Monad (LogicCPS r) where\n>     LogicCPS c >>= f =\n>         LogicCPS (\\sk fk -> c (\\a rk -> runLogicCPS (f a) sk rk) fk)\n>     return x = LogicCPS (\\sk fk -> sk x fk)\n\n```", "```\n> nilCPS =\n>     LogicCPS (\\_ fk -> fk)\n> consCPS x (LogicCPS c) =\n>     LogicCPS (\\sk fk -> sk x (c sk fk))\n> appendCPS (LogicCPS cl) (LogicCPS cr) =\n>     LogicCPS (\\sk fk -> cl sk (cr sk fk))\n\n```", "```\nfoldr :: (a -> b -> b) -> b -> [a] -> b\n\n```", "```\nfold :: List a -> (a -> r -> r) -> r -> r\n\n```", "```\n> data Leafy a = Leaf a | Fork (Leafy a) (Leafy a)\n> instance Monad Leafy where\n>     Leaf a >>= f = f a\n>     Fork l r >>= f = Fork (l >>= f) (r >>= f)\n>     return a = Leaf a\n\n```", "```\n> leafCPS x = return x\n> forkCPS l r = appendCPS l r\n\n```", "```\n> data Catenable a = Append (Catenable a) (Catenable a) | List (List a)\n\n```"]