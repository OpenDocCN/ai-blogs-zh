["```\n> {-# LANGUAGE GeneralizedNewtypeDeriving #-}\n> import Control.Comonad\n> import Data.List\n\n```", "```\n> newtype Causal a = Causal [a]\n>    deriving (Functor, Show)\n>\n> causal :: a -> [a] -> Causal a\n> causal x xs = Causal (x:xs)\n>\n> unCausal :: Causal a -> [a]\n> unCausal (Causal xs) = xs\n>\n> type Voltage = Float\n\n```", "```\n(u ∗ f)[n] = sum from m = -∞ to ∞ of f[m]u[n-m]\n\n```", "```\nf[n] = f[0]δ[n] + f[1]δ[n-1] + ...\n\n```", "```\ng[n] = f[0]u[n] + f[1]u[n-1] + ...\n     = sum from m = 0 to ∞ of f[m]u[n-m]\n\n```", "```\n> ltiChannel :: [Voltage] -> Causal Voltage -> Voltage\n> ltiChannel u = \\(Causal f) -> sum $ zipWith (*) (reverse f) u\n\n```", "```\n> usr :: [Voltage]\n> usr = [1,2,5,2,1]\n\n```", "```\nclass Functor f => Copointed f where\n    extract :: f a -> a\n\nclass Copointed w => Comonad w where\n    duplicate :: w a -> w (w a)\n    extend :: (w a -> b) -> w a -> w b\n\n```", "```\n> instance Copointed Causal where\n>    extract (Causal xs) = head xs\n\n```", "```\n> instance Comonad Causal where\n>    extend f  = Causal . map (f . Causal) . tail . inits . unCausal\n>    duplicate = Causal . map      Causal  . tail . inits . unCausal\n\n```", "```\ninstance Comonad [] where\n    extend f  = map f . tail . inits\n    duplicate = tail . inits\n\n```", "```\n> unitStep :: Causal Voltage\n> unitStep = Causal (repeat 1)\n>\n> result :: Causal Voltage\n> result = unitStep =>> ltiChannel usr\n\n```", "```\nCausal [1.0, 3.0, 8.0, 10.0, 11.0, 11.0, ...]\n\n```", "```\n> tiChannel :: ([Voltage] -> Voltage) -> Causal Voltage -> Voltage\n> tiChannel f (Causal xs) = f (reverse xs ++ repeat 0)\n>\n> ltiChannel' :: [Voltage] -> Causal Voltage -> Voltage\n> ltiChannel' u = tiChannel (\\xs -> sum $ zipWith (*) u xs)\n\n```"]