["```\n\"inplace/bin/ghc-stage1\" (...) -o compiler/stage2/build/FastString.o\nghc-stage1: panic! (the 'impossible' happened)\n  (GHC version 7.1 for i386-unknown-linux):\n       RegAllocLinear.makeRegMovementGraph\n\nPlease report this as a GHC bug:  http://www.haskell.org/ghc/reportabug\n\n```", "```\n-- | Construct a graph of register\\/spill movements.\n--\n--  Cyclic components seem to occur only very rarely.\n--\n--  We cut some corners by not handling memory-to-memory moves.\n--  This shouldn't happen because every temporary gets its own stack slot.\n--\nmakeRegMovementGraph :: RegMap Loc -> RegMap Loc -> [(Unique, Loc, [Loc])]\nmakeRegMovementGraph adjusted_assig dest_assig\n = let\n        mkNodes src vreg\n         = expandNode vreg src\n         $ lookupWithDefaultUFM_Directly\n                dest_assig\n                (panic \"RegAllocLinear.makeRegMovementGraph\")\n                vreg\n\n   in       [ node  | (vreg, src) <- ufmToList adjusted_assig\n                , node <- mkNodes src vreg ]\n\n```", "```\n$ \"inplace/bin/ghc-stage1\" (...) -o compiler/stage2/build/FastString.o -dopt-fuel=0\n\n```", "```\n$ \"inplace/bin/ghc-stage1\" (...) -o compiler/stage2/build/FastString.o -dopt-fuel=1000 -fforce-recomp\nghc-stage1: panic! (the 'impossible' happened)\n  (GHC version 7.1 for i386-unknown-linux):\n       RegAllocLinear.makeRegMovementGraph\n\nPlease report this as a GHC bug:  http://www.haskell.org/ghc/reportabug\n\n```", "```\n$ \"inplace/bin/ghc-stage1\" (...) -o compiler/stage2/build/FastString.o -dopt-fuel=709 -fforce-recomp\n$ \"inplace/bin/ghc-stage1\" (...) -o compiler/stage2/build/FastString.o -dopt-fuel=710 -fforce-recomp\nghc-stage1: panic! (the 'impossible' happened)\n  (GHC version 7.1 for i386-unknown-linux):\n       RegAllocLinear.makeRegMovementGraph\n\n```", "```\n@@ -10059,7 +10059,6 @@\n         }\n     c45T:\n         _s3es::I32 = I32[Sp + 4];\n-        _s3eu::I32 = I32[Sp + 0];\n         // deleted: if (0) goto c460;\n         // outOfLine should follow:\n         _s3er::I32 = 0;\n@@ -10093,1354 +10092,3 @@\n         jump (I32[Sp + 0]) ();\n }\n\n```", "```\nFastString.$whashStr_entry()\n        { [const 131081;, const 0;, const 15;]\n        }\n    c45T:\n        _s3es::I32 = I32[Sp + 4];\n        _s3eu::I32 = I32[Sp + 0]; // deleted assignment\n        _s3er::I32 = 0;\n        _s3ex::I32 = 0;\n        goto c463;\n    c460:\n        R1 = FastString.$whashStr_closure;\n        jump (I32[BaseReg - 4]) ();\n    c463:\n        if (I32[GHC.Types.Bool_closure_tbl + ((_s3er::I32 == _s3es::I32) << 2)] & 3 >= 2) goto c46d;\n        // uh oh, assignment used here\n        _s3IC::I32 = %MO_S_Rem_W32(%MO_UU_Conv_W8_W32(I8[_s3eu::I32 + (_s3er::I32 << 0)]) + _s3ex::I32 * 128,\n                                   4091);\n        _s3er::I32 = _s3er::I32 + 1;\n        _s3ex::I32 = _s3IC::I32;\n        goto c463;\n    c46d:\n        R1 = _s3ex::I32;\n        Sp = Sp + 8;\n        jump (I32[Sp + 0]) ();\n}\n\n```", "```\nhashStr  :: Ptr Word8 -> Int -> Int\nhashStr (Ptr a#) (I# len#) = loop 0# 0#\n   where\n    loop h n | n GHC.Exts.==# len# = I# h\n             | otherwise  = loop h2 (n GHC.Exts.+# 1#)\n          where !c = ord# (indexCharOffAddr# a# n)\n                !h2 = (c GHC.Exts.+# (h GHC.Exts.*# 128#)) `remInt#` 4091#\n\n```", "```\n==================== Post Proc Points Added ====================\n{offset\n  c43r:\n      _s3es::I32 = I32[(old + 8)];\n      _s3eu::I32 = I32[(old + 12)];\n      if (Sp - <highSp> < SpLim) goto c43y; else goto c43u;\n\n==================== Post spills and reloads ====================\n{offset\n  c43r:\n      _s3es::I32 = I32[(old + 8)];\n      _s3eu::I32 = I32[(old + 12)];\n      if (Sp - <highSp> < SpLim) goto c43y; else goto c43u;\n\n==================== Post rewrite assignments ====================\n{offset\n  c43r:\n      _s3es::I32 = I32[(old + 8)];\n      if (Sp - <highSp> < SpLim) goto c43y; else goto c43u;\n\n```", "```\nusageRewrite :: BwdRewrite FuelUniqSM (WithRegUsage CmmNode) UsageMap\nusageRewrite = mkBRewrite3 first middle last\n    where first  _ _ = return Nothing\n          middle :: Monad m => WithRegUsage CmmNode O O -> UsageMap -> m (Maybe (Graph (WithRegUsage CmmNode) O O))\n          middle (Plain (CmmAssign (CmmLocal l) e)) f\n                     = return . Just\n                     $ case lookupUFM f l of\n                            Nothing    -> emptyGraph\n                            Just usage -> mkMiddle (AssignLocal l e usage)\n          middle _ _ = return Nothing\n          last   _ _ = return Nothing\n\n```"]