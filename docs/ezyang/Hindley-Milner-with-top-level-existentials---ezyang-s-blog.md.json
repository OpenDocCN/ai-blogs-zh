["```\n-- Hindley Milner\nid :: a -> a\nid = λx. x\n\n-- System F\nid :: ∀a. a -> a\nid = Λa. λ(x : a). x\n\n```", "```\nTypes  τ ::= ... | ∃a. τ\nTerms  e ::= ... | pack <τ, e>_τ | unpack <a, x> = e in e\n\n```", "```\n{-# LANGUAGE ExistentialQuantification #-}\ndata Ex f = forall a. Ex (f a)\npack :: f a -> Ex f\npack = Ex\nunpack :: Ex f -> (forall a. f a -> r) -> r\nunpack m k = case m of Ex x -> f x\n\n```", "```\n{-# LANGUAGE RankNTypes #-}\ntype Ex f = forall r. (forall a. f a -> r) -> r\npack :: f a -> Ex f\npack x = \\k -> k x\nunpack :: Ex f -> (forall a. f a -> r) -> r\nunpack m k = m k\n\n```", "```\nwrap :: forall a. a -> [a]\nkey  :: exists b. Key b\n-- What is the type of 'wrap key'?\n-- [exists b. Key b]?\n-- exists b. [key b]?\n\n```", "```\nTerm variables ∈ f, x, y, z\nType variables ∈ a, b, c\n\nPrograms\nprog ::= let f = e in prog\n       | seal (b*, f :: σ) = (τ*, e) in prog\n       | {- -}\n\nType schemes (polytypes)\nσ ::= ∀a*. τ\n\nExpressions\ne ::= x\n    | \\x -> e\n    | e e\n\nMonotypes\nτ ::= a\n    | τ -> τ\n\n```", "```\nΓ ⊢ e :: τ₀[b* → τ*]\na* = free-vars(τ₀[b* → τ*])\nΓ, b*, (f :: ∀a*. τ₀) ⊢ prog\n---------------------------------------------\nΓ ⊢ seal (b*, f :: ∀a*. τ₀) = (τ*, e) in prog\n\n```", "```\nseal (b*, f :: σ) = (τ*, e) in prog\n  ===>\nunpack <b*, f> = pack <τ*, e>_{∃b*. σ} in prog\n\n```"]