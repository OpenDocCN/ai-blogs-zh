- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-07-01 18:18:27'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: 'Nested loops and continuations : ezyang’s blog'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[http://blog.ezyang.com/2010/02/nested-loops-and-continuation/](http://blog.ezyang.com/2010/02/nested-loops-and-continuation/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The bread and butter of an imperative programmer is the loop. Coming from a
    C/assembly perspective, a loop is simply a structured goto which jumps back to
    a set location if some condition is not met. Frequently, this loop ranges over
    the elements of some list data structure. In C, you might be doing pointer arithmetic
    over the elements of an array or following pointers on a linked list until you
    get `NULL`; in Python and other higher-level languages you get the `for x in xs`
    construct which neatly abstracts this functionality. Inside of a loop, you also
    have access to the flow control operators `break` and `continue`, which are also
    highly structured gotos. An even more compact form of loops and nested loops are
    list comprehensions, which don't permit those flow operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'Haskell encourages you to use the higher order forms such as `map` and `fold`,
    which even further restrict what may happen to the data. You''ll certainly not
    see a `for` loop anywhere in Haskell... However, as a pernicious little exercise,
    and also a way to get a little more insight into what `callCC` might be good for,
    I decided to implement `for...in` loops with both the `continue` and `break` keywords.
    The end hope is to be able to write code such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'as well as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'the latter solving the classic "nested loops" problem by explicitly labeling
    each loop. We might run these pieces of code using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Since continuations represent, well, "continuations" to the program flow, we
    should have some notion of a continuation that functions as `break`, as well as
    a continuation that functions as `continue`. We will store the continuations that
    correspond to breaking and continuing inside a loop "label", which is the first
    argument of our hanging lambda:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: It's sufficient then to call `continue label` or `break label` inside the monad
    to extract and follow the continuation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next bit is to implement the actual `for_in` construct. If we didn''t have
    to supply any of the continuations, this is actually just a flipped `mapM_`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, sample code, `f` has the type `Label m -> a -> m ()`, so this won''t
    do! Consider this first transformation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This function does the same thing as `for_in'`, but we placed it inside the
    continuation monad and made explicit a variable `c`. What does the current continuation
    `c` correspond to in this context? Well, it's in the very outer context, which
    means the "current continuation" is completely out of the loop. That must mean
    it's the `break` continuation. Cool.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this second alternative transformation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This time, we've replaced `f` with a wrapper lambda that uses `callCC` before
    actually calling `f`, and the current continuation results in the next step of
    `mapM_` being called. This is the `continue` continuation.
  prefs: []
  type: TYPE_NORMAL
- en: 'All that remains is to stick them together, and package them into the `Label`
    datatype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*Et voila!* Imperative looping constructs in Haskell. (Not that you''d ever
    want to use them, nudge nudge wink wink.)'
  prefs: []
  type: TYPE_NORMAL
- en: '*Addendum.* Thanks to Nelson Elhage and Anders Kaseorg for pointing out a stylistic
    mistake: storing the continuations as `() -> m ()` is unnecessary because Haskell
    is a lazy language (in my defense, the imperative paradigm was leaking in!)'
  prefs: []
  type: TYPE_NORMAL
- en: '*Addendum 2.* Added type signatures and code for running the initial two examples.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Addendum 3.* Sebastian Fischer points out a mistake introduced by addendum
    1\. That''s what I get for not testing my edits!'
  prefs: []
  type: TYPE_NORMAL
