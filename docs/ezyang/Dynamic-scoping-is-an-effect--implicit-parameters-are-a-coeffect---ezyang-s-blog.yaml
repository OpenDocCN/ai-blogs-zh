- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-07-01 18:16:50'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: 'Dynamic scoping is an effect, implicit parameters are a coeffect : ezyang’s
    blog'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[http://blog.ezyang.com/2020/08/dynamic-scoping-is-an-effect-implicit-parameters-are-a-coeffect/](http://blog.ezyang.com/2020/08/dynamic-scoping-is-an-effect-implicit-parameters-are-a-coeffect/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For the longest time, I thought of [implicit parameters](https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#implicit-parameters)
    and dynamic scoping were basically the same thing, since they both can be used
    to solve similar problems (e.g., the so called "configuration problem" where you
    need to plumb down some configuration deep into a nested body of function definitions
    without defining them all explicitly). But implicit parameters have a reputation
    of being [something you shouldn't use](https://www.reddit.com/r/haskell/comments/6gz4w5/whats_wrong_with_implicitparams/)
    ([use reflection instead](https://www.reddit.com/r/haskell/comments/5xqozf/implicit_parameters_vs_reflection/dek9eqg/)),
    whereas dynamic scoping via the reader monad is a useful and well understood construct
    (except for the bit where you have to monadify everything). Why the difference?
  prefs: []
  type: TYPE_NORMAL
- en: '[Oleg](http://okmij.org/ftp/Computation/dynamic-binding.html#implicit-parameter-neq-dynvar)
    points out that implicit parameters are not really dynamic scoping, and gives
    an example where Lisp and Haskell disagree. And you don''t even want the Lisp
    behavior in Haskell: if you think about the operational notion of dynamic scoping
    (walk up the stack until you find a binding site of the dynamic variable), it''s
    not very compatible with laziness, since a thunk (which accesses a dynamic variable)
    will be forced at some unpredictable point in program execution. You really don''t
    want to have to reason about where exactly a thunk will be executed to know how
    its dynamic variables will be bound, that way lies madness. But somehow, in a
    strict language, no one has trouble figuring out what should happen with dynamic
    scoping ([well](https://blog.klipse.tech/clojure/2018/12/25/dynamic-scope-clojure.html),
    [mostly](https://stuartsierra.com/2013/03/29/perils-of-dynamic-scope)--more on
    this shortly).'
  prefs: []
  type: TYPE_NORMAL
- en: 'It turns out that the research community has figured out the difference is
    that implicit parameters are a coeffect. I believe this was first observed in
    [Coeffects: Unified static analysis of context-dependence](http://tomasp.net/academic/papers/coeffects/coeffects-icalp.pdf)
    (a more modern presentation is in [Coeffects: A calculus of context-dependent
    computation](https://www.doc.ic.ac.uk/~dorchard/publ/coeffects-icfp14.pdf); and
    a more Haskelly presentation can be found in [Embedding effect systems in Haskell](http://tomasp.net/academic/papers/haskell-effects/haskell-effects.pdf)).
    Although, Tomas was [commenting on my blog in 2012](http://blog.ezyang.com/2012/10/generalizing-the-programmable-semicolon/)
    about similar ideas, so this probably had been in the works for a while. The key
    point is that for some coeffects (namely, implicit parameters), call-by-name reduction
    preserves types and coeffects, and so implicit parameters do not blow up in your
    face in the same way dynamic scoping (an effect) would. These necessarily behave
    differently! Type classes are coeffects too, and this is why modern use of implicit
    parameters in Haskell explicitly acknowledges this (e.g., in the reflection package).'
  prefs: []
  type: TYPE_NORMAL
- en: At this year's ICFP, I was pointed at an interesting technical report about
    [implicit values and functions](https://www.microsoft.com/en-us/research/uploads/prod/2019/03/implicits-tr-v2.pdf)
    in Koka, a new twist on the dynamic scoping. I found myself wondering if Haskell
    implicit parameters could learn a thing or two from this work. Implicit values
    make the good choice of defining implicit values globally at the top level, so
    that they can participate in normal module namespacing, as opposed to an un-namespaced
    bag of dynamically scoped names (this is also an improvement that reflection makes
    over implicit parameters). But actually, it seems to me that implicit functions
    are taking a page from implicit parameters!
  prefs: []
  type: TYPE_NORMAL
- en: The big innovation is the implicit function is that it resolves all dynamic
    references in the function (not just lexically, but for all further dynamic calls)
    to the lexical scope (the dynamic scope at the time the function was defined),
    producing a function that has no dependence on implicit values (aka, has no *effect*
    saying that the implicit value must be defined at the time the function is called.)
    This is exactly what an implicit parameter `let ?x = ...` binding would have done,
    in effect directly filling in the dictionary for the implicit function at definition
    site, rather than waiting. Very contextual! (Of course, Koka implements this using
    algebraic effects, and gets to the right semantics with a very simple translation
    anyway). The result is not exactly dynamic scoping, but as the TR says, it leads
    to better abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: It is difficult to see how implicit values/functions could make their way back
    into Haskell, at least without some sequencing constructing (e.g., a monad) lurking
    around. Though implicit functions behave much like implicit parameters, the rest
    of the dynamic scoping (including the binding of the implicit function itself)
    is just good old effectful (not coeffectful) dynamic scope. And you can't just
    do that in Haskell, without breaking type preservation under beta-reduction and
    eta-expansion. Haskell has no choice but to go *all the way*, and once you get
    beyond the obvious problems of implicit parameters (which reflection fixes), things
    seem to mostly work out.
  prefs: []
  type: TYPE_NORMAL
