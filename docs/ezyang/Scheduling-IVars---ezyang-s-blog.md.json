["```\nimport Data.IORef\n\ndata IVarContents a =\n    Blocking [a -> IO ()]\n  | Full a\n\ntype Schedule = [IO ()]\ntype IVar a = IORef (IVarContents a)\n\nnewtype T a = T { runT :: IORef Schedule -> IO (IVar a) }\n\ninstance Monad T where\n  return x = T (\\_ -> newIORef (Full x))\n  m >>= f  = T $ \\sched ->\n        do xref <- runT m sched\n           mx <- readIORef xref\n           case mx of\n             Full x      -> runT (f x) sched\n             Blocking cs -> do\n                    r <- newIORef (Blocking [])\n                    let callback x = do\n                        y <- runT (f x) sched\n                        addCallback y (fillIVar sched r)\n                    addCallback xref callback\n                    return r\n\naddCallback :: IVar a -> (a -> IO ()) -> IO ()\naddCallback r c = do\n    rc <- readIORef r\n    case rc of\n        Full x -> c x\n        Blocking cs -> writeIORef r (Blocking (c:cs))\n\nfillIVar :: IORef Schedule -> IVar a -> a -> IO ()\nfillIVar sched ref x = do\n  r <- readIORef ref\n  writeIORef ref (Full x)\n  case r of\n    Blocking cs -> schedule sched (map ($x) cs)\n    Full _ -> error \"fillIVar: Cannot write twice\"\n\n-- FIFO scheduler\nschedule :: IORef Schedule -> [IO ()] -> IO ()\nschedule sched to_sched = do\n    cur <- readIORef sched\n    writeIORef sched (cur ++ to_sched)\n\nrun :: T () -> IO ()\nrun initial_job = do\n    sched <- newIORef []\n    writeIORef sched [runT initial_job sched >> return ()]\n    let go = do\n        jobs <- readIORef sched\n        case jobs of\n            [] -> return ()\n            (job:rest) -> writeIORef sched rest >> job >> go\n    go\n\n```", "```\n-- Does more work than return (), but semantically the same\ntick :: T ()\ntick = T $ \\sched ->\n        do r <- newIORef (Blocking [])\n           schedule sched [fillIVar sched r ()]\n           return r\n\nmain = run loop\nloop = tick >> loop\n\n```"]