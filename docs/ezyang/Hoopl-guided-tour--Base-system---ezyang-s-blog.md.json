["```\nanalyzeAndRewriteFwd\n   :: forall m n f e x entries. (CheckpointMonad m, NonLocal n, LabelsPtr entries)\n   => FwdPass m n f\n   -> MaybeC e entries\n   -> Graph n e x -> Fact e f\n   -> m (Graph n e x, FactBase f, MaybeO x f)\n\n```", "```\ndata Proc = Proc { name :: String, args :: [Var], body :: [Block] }\ndata Block = Block { first :: Lbl, mids :: [Insn], last :: Control }\ndata Insn = Assign Var  Expr\n          | Store  Expr Expr\ndata Control = Branch Lbl\n             | Cond   Expr   Lbl    Lbl\n             | Call   [Var]  String [Expr] Lbl\n             | Return [Expr]\ntype Lbl = String\n\n```", "```\ndata Proc = Proc { name :: String, args :: [Var], entry :: Label, body :: Graph Insn C C }\ndata Insn e x where\n  Label  :: Label  ->                               Insn C O\n  Assign :: Var    -> Expr    ->                    Insn O O\n  Store  :: Expr   -> Expr    ->                    Insn O O\n  Branch :: Label  ->                               Insn O C\n  Cond   :: Expr   -> Label   -> Label  ->          Insn O C\n  Call   :: [Var]  -> String  -> [Expr] -> Label -> Insn O C\n  Return :: [Expr] ->                               Insn O C\n\n```", "```\n> isLabel :: Insn e x -> Bool\n> isLabel Label{} = True\n> isLabel _ = False\n> \n> ```", "```\n> assertLabel :: Insn C O -> Bool\n> assertLabel Label{} = True\n> \n> ```", "```\n> <interactive>:1:13:\n>     Couldn't match expected type `C' against inferred type `O'\n>       Expected type: Insn C O\n>       Inferred type: Insn O C\n>     In the first argument of `assertLabel', namely `(Branch undefined)'\n>     In the expression: assertLabel (Branch undefined)\n> \n> ```", "```\n> transferMiddle :: Insn O O -> Bool\n> transferMiddle Assign{} = True\n> transferMiddle Store{} = False\n> \n> ```", "```\n> transferMiddleOrEnd :: Insn O x -> Bool\n> \n> ```", "```\nastToIR :: A.Proc -> I.M I.Proc\nastToIR (A.Proc {A.name = n, A.args = as, A.body = b}) = run $\n  do entry <- getEntry b\n     body  <- toBody   b\n     return $ I.Proc { I.name  = n, I.args = as, I.body = body, I.entry = entry }\n\n```", "```\ngetEntry :: [A.Block] -> LabelMapM Label\ngetEntry [] = error \"Parsed procedures should not be empty\"\ngetEntry (b : _) = labelFor $ A.first b\n\n```", "```\ntoBody :: [A.Block] -> LabelMapM (Graph I.Insn C C)\ntoBody bs =\n  do g <- foldl (liftM2 (|*><*|)) (return emptyClosedGraph) (map toBlock bs)\n     getBody g\n\n```", "```\ntoBlock :: A.Block -> LabelMapM (Graph I.Insn C C)\ntoBlock (A.Block { A.first = f, A.mids = ms, A.last = l }) =\n  do f'  <- toFirst f\n     ms' <- mapM toMid ms\n     l'  <- toLast l\n     return $ mkFirst f' <*> mkMiddles ms' <*> mkLast l'\n\n```", "```\ntoFirst :: A.Lbl -> LabelMapM (I.Insn C O)\ntoFirst = liftM I.Label . labelFor\n\ntoMid :: A.Insn -> LabelMapM (I.Insn O O)\ntoMid (A.Assign v e) = return $ I.Assign v e\ntoMid (A.Store  a e) = return $ I.Store  a e\n\ntoLast :: A.Control -> LabelMapM (I.Insn O C)\ntoLast (A.Branch l)   = labelFor l >>= return . I.Branch\ntoLast (A.Cond e t f) = labelFor t >>= \\t' ->\n                        labelFor f >>= \\f' -> return (I.Cond e t' f')\ntoLast (A.Call rs f as l) = labelFor l >>= return . I.Call rs f as\ntoLast (A.Return es)      = return $ I.Return es\n\n```"]