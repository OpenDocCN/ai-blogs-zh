["```\nfn main() {\n  let mut map = std::hashmap::HashMap::new();\n  map.insert(1, 2);\n  map.insert(2, *map.get(&1)); // XXX\n}\n\ntest.rs:4:17: 4:20 error: cannot borrow `map` as immutable because it is also borrowed as mutable\ntest.rs:4   map.insert(2, *map.get(&1)); // XXX\n                           ^~~\ntest.rs:4:2: 4:5 note: second borrow of `map` occurs here\ntest.rs:4   map.insert(2, *map.get(&1)); // XXX\n            ^~~\n\n```", "```\nlet x_self : &mut HashMap<int> = &mut map;\nlet x_arg1 : int = 2;\nlet x_arg2 : int = *map.get(&1); // XXX\nHashMap::insert(x_self, x_arg1, x_arg2);\n\n```", "```\nfn main() {\n  let mut map = std::hashmap::HashMap::new();\n  map.insert(1, 2);\n  let x = *map.get(&1);\n  map.insert(2, x);\n}\n\n```", "```\nfn g(x: &mut int) -> int { *x }\nfn f(x: &mut int, y: int) { *x += y; }\nfn main() {\n    let mut a = 1;\n    f(&mut a, g(&mut a));\n}\n\n```", "```\nfn main() {\n    let mut x = ~1;\n    let y = &mut *x;\n    *y = 1;\n    let z = &mut *x;\n    *z = 1;\n}\n\ntest.rs:5:12: 5:19 error: cannot borrow `*x` as mutable more than once at a time\ntest.rs:5     let z = &mut *x;\n                      ^~~~~~~\ntest.rs:3:12: 3:19 note: second borrow of `*x` as mutable occurs here\ntest.rs:3     let y = &mut *x;\n                      ^~~~~~~\n\n```", "```\nfn main() {\n    let mut x = ~1;\n    {\n        let y = &mut *x;\n        *y = 1;\n    }\n    let z = &mut *x;\n    *z = 1;\n}\n\n```", "```\nextern mod extra;\nfn main() {\n    let mut table = extra::treemap::TreeMap::new();\n    let key = ~\"test1\";\n    match table.find_mut(&key) {\n        None    => table.insert(key.clone(), ~[1]), // XXX\n        Some(v) => { v.push(1); false }\n    };\n}\n\ntest.rs:6:19: 6:24 error: cannot borrow `table` as mutable more than once at a time\ntest.rs:6         None    => table.insert(key.clone(), ~[1]), // XXX\n                             ^~~~~\ntest.rs:5:10: 5:15 note: second borrow of `table` as mutable occurs here\ntest.rs:5     match table.find_mut(&key) {\n                    ^~~~~\n\n```", "```\npub fn read1<'a>(&'a mut self, key: int) -> Option<&'a Data> {\n    match self.cache.find(&key) {\n        Some(data) => return Some(data),\n        None => ()\n    };\n    match self.db.find(&key) {\n        Some(data) => {\n            let result: &Data = self.cache.find_or_insert(key, data.clone());\n            Some(result)\n        },\n        None => None\n    }\n}\n\ntest.rs:22:36: 22:46 error: cannot borrow `(*self).cache` as mutable because it is also borrowed as immutable\ntest.rs:22                 let result: &Data = self.cache.find_or_insert(key, data.clone());\n                                               ^~~~~~~~~~\ntest.rs:15:14: 15:24 note: second borrow of `(*self).cache` occurs here\ntest.rs:15         match self.cache.find(&key) {\n                         ^~~~~~~~~~\n\n```", "```\nextern mod extra;\nuse extra::treemap::TreeMap;\nfn main() {\n    let mut table: TreeMap<~str,~[int]> = TreeMap::new();\n    let key = ~\"test1\";\n    match table.find_mut(&key) {\n        None    => {},\n        Some(v) => { v.push(1); return }\n    };\n    table.insert(key.clone(), ~[1]); // None-case\n}\n\n```", "```\nextern mod extra;\nuse extra::treemap::TreeMap;\nfn main() {\n    let mut table: TreeMap<~str,~[int]> = TreeMap::new();\n    let key = ~\"test1\";\n    let is_none = match table.find_mut(&key) {\n        None    => true,\n        Some(v) => { v.push(1); false }\n    };\n    if is_none {\n        table.insert(key.clone(), ~[1]);\n    }\n}\n\n```"]