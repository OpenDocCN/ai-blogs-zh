- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-07-01 18:18:27'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: 'Nested loops and exceptions (Oleg Kiselyov) : ezyang’s blog'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[http://blog.ezyang.com/2010/02/nested-loops-and-exceptions-oleg-kiselyov/](http://blog.ezyang.com/2010/02/nested-loops-and-exceptions-oleg-kiselyov/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Editorial.* Today we interrupt our regularly scheduled programming to bring
    you a guest post by [Oleg Kiselyov](http://okmij.org/ftp/), reinterpreting our
    previous post about [nested loops and continuations](http://blog.ezyang.com/2010/02/nested-loops-and-continuation/)
    with exceptions.'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Hello!
  prefs: []
  type: TYPE_NORMAL
- en: I noticed your recent article about nested loops and continuations. I should
    have commented on it using the provided form, but I was not sure how formatting
    would come out. The comment includes a lot of code. Please feel free to post the
    code in whole or in part, or do anything else with it.
  prefs: []
  type: TYPE_NORMAL
- en: The thesis of my comment is that `callCC` is not necessary for the implementation
    of break and continue in single and nested loops. We observe that the continuations
    of each iteration and of the entire loop are invoked either 0 or 1 time (but never
    more than once). That is the pattern of exceptions. So, the problem posed by your
    article can be solved with exceptions. Here are several variations of the solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, a few preliminaries: this message is the complete literate Haskell code.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Alas, `ErrorT` in `Control.Monad.Error` has the stupid `Error` constraint. So,
    we have to write our own Exception monad transformer. The code below is standard.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We are ready to code the first solution, for simple, non-nested loops. The
    idea is to treat ''break'' and ''continue'' as exceptions. After all, both control
    operators cause computations to be skipped—which is what exceptions do. We define
    the datatype of our ''exceptions'':'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the code for the loop: it catches exceptions at some points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is your test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Running it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: prints 23 numbers starting with 0, 2, 3 and ending with 30, 32, 33.
  prefs: []
  type: TYPE_NORMAL
- en: We have to generalize to nested loops. Two solutions are apparent. I would call
    the first one 'dynamic'. We index the exceptions by levels, which are natural
    numbers. Level 0 pertains to the current loop, level 1 is for the parent loop,
    etc.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Operators break and continue now take the number: how many loop scopes to break.
    I think Perl has a similar breaking-with-number operator.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The new iterator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The single-loop test now looks as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now write the nested loop test. I took a liberty to enhance the example
    in your article, so to exercises all cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is the sequence of numbers: 1 4 5 1 2 4 5 3 4 5'
  prefs: []
  type: TYPE_NORMAL
- en: 'There exists another solution for the nested-loop problem, which I call ''static''.
    What if we just iterate the single-loop solution? We can nest `ExT` `BC` monad
    transformers to any given depth. To refer to particular layer in the transformer
    stack, we use lift. We can use the for_in iterator and the operators break, continue
    defined earlier. We write the nested test as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'I guess the lesson here might be that `callCC` is often not needed (I would
    argue that `callCC` is never needed, but that''s the argument for another time).
    Here is another example of simple exceptions sufficing where call/cc was thought
    to be required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://okmij.org/ftp/Computation/lem.html](http://okmij.org/ftp/Computation/lem.html)'
  prefs: []
  type: TYPE_NORMAL
