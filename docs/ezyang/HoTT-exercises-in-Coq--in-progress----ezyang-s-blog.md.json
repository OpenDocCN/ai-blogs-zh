["```\nRequire Import HoTT.\n\nDefinition admit {T: Type} : T. Admitted.\n\n(* Exercise 1.1 *)\nDefinition mycompose {A B C : Type} (g : B -> C) (f : A -> B) : A -> C := admit.\n\nGoal forall (A B C D : Type) (f : A -> B) (g : B -> C) (h : C -> D),\n       mycompose h (mycompose g f) = mycompose (mycompose h g) f.\nAdmitted.\n\n(* Exercise 1.2 *)\nSection ex_1_2_prod.\n  Variable A B : Type.\n  Check @fst.\n  Check @snd.\n  Definition my_prod_rec (C : Type) (g : A -> B -> C) (p : A * B) : C := admit.\n  Goal fst = my_prod_rec A (fun a => fun b => a). Admitted.\n  Goal snd = my_prod_rec B (fun a => fun b => b). Admitted.\nEnd ex_1_2_prod.\n\nSection ex_1_2_sig.\n  Variable A : Type.\n  Variable B : A -> Type.\n  Check @projT1.\n  Check @projT2.\n  Definition my_sig_rec (C : Type) (g : forall (x : A), B x -> C) (p : exists (x : A), B x) : C := admit.\n  Goal @projT1 A B = my_sig_rec A (fun a => fun b => a). Admitted.\n  (* What goes wrong when you try to prove this for projT2? *)\nEnd ex_1_2_sig.\n\n(* Exercise 1.3 *)\n\nDefinition refl {A : Type} (x : A) : x = x := 1%path.\n\nSection ex_1_3_prod.\n  Variable A B : Type.\n  (* Given by the book *)\n  Definition uppt : forall (x : A * B), ((fst x, snd x) = x) :=\n    fun p => match p with (a,b) => refl (a,b) end.\n  Definition my_prod_ind (C : A * B -> Type) (g : forall (x : A) (y : B), C (x, y)) (x : A * B) : C x := admit.\n  Goal forall C g a b, my_prod_ind C g (a, b) = g a b. Admitted.\nEnd ex_1_3_prod.\n\nSection ex_1_3_sig.\n  Variable A : Type.\n  Variable B : A -> Type.\n  Definition sig_uppt : forall (x : exists (a : A), B a), ((projT1 x; projT2 x) = x) := admit.\n  Definition mysig_ind (C : (exists (a : A), B a) -> Type) (g : forall (a : A) (b : B a), C (a; b)) (x : exists (a : A), B a) : C x := admit.\n  Goal forall C g a b, mysig_ind C g (a; b) = g a b. Admitted.\nEnd ex_1_3_sig.\n\n(* Exercise 1.4 *)\nFixpoint iter (C : Type) (c0 : C) (cs : C -> C) (n : nat) : C :=\n  match n with\n    | 0 => c0\n    | S n' => cs (iter C c0 cs n')\n  end.\nDefinition mynat_rec (C : Type) : C -> (nat -> C -> C) -> nat -> C := admit.\nEval compute in mynat_rec (list nat) nil (@cons nat) 2.\nEval compute in nat_rect (fun _ => list nat) nil (@cons nat) 2.\n\n(* Exercise 1.5 *)\nDefinition mycoprod (A B : Type) := exists (x : Bool), Bool_rect (fun _ => Type) A B x.\n\nSection ex_1_5.\n  Variable A B : Type.\n  Definition inl := existT (Bool_rect (fun _ => Type) A B) true.\n  Definition inr := existT (Bool_rect (fun _ => Type) A B) false.\n  Definition mycoprod_ind (C : mycoprod A B -> Type)\n                          (l : forall (a : A), C (inl a))\n                          (r : forall (b : B), C (inr b))\n                          (x : mycoprod A B) : C x := admit.\n  Goal forall C l r x, mycoprod_ind C l r (inl x) = l x. Admitted.\n  Goal forall C l r x, mycoprod_ind C l r (inr x) = r x. Admitted.\nEnd ex_1_5.\n\n(* Exercise 1.6 *)\n\nDefinition myprod (A B : Type) := forall (x : Bool), Bool_rect (fun _ => Type) A B x.\nSection ex_1_6.\n  Context `{Funext}.\n  Variable A B : Type.\n  Definition mypr1 (p : myprod A B) := p true.\n  Definition mypr2 (p : myprod A B) := p false.\n  Definition mymkprod (a : A) (b : B) : myprod A B := Bool_rect (Bool_rect (fun _ => Type) A B) a b.\n  Definition myprod_ind (C : myprod A B -> Type)\n                        (g : forall (x : A) (y : B), C (mymkprod x y)) (x : myprod A B) : C x := admit.\n  Goal forall C g a b, myprod_ind C g (mymkprod a b) = g a b. Admitted.\nEnd ex_1_6.\n\n```"]