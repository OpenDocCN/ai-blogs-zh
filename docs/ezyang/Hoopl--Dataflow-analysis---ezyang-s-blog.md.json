["```\nliveness :: BwdTransfer Insn Live\nliveness = mkBTransfer live\n  where\n    live :: Insn e x -> Fact x Live -> Live\n    live   (Label _)       f = f\n    live n@(Assign x _)    f = addUses (S.delete x f) n\n    live n@(Store _ _)     f = addUses f n\n    live n@(Branch l)      f = addUses (fact f l) n\n    live n@(Cond _ tl fl)  f = addUses (fact f tl `S.union` fact f fl) n\n    live n@(Call vs _ _ l) f = addUses (fact f l `S.difference` S.fromList vs) n\n    live n@(Return _)      _ = addUses (fact_bot liveLattice) n\n\n    fact :: FactBase (S.Set Var) -> Label -> Live\n    fact f l = fromMaybe S.empty $ lookupFact l f\n\n    addUses :: S.Set Var -> Insn e x -> Live\n    addUses = fold_EN (fold_EE addVar)\n    addVar s (Var v) = S.insert v s\n    addVar s _       = s\n\n```", "```\ntype family   Fact x f :: *\ntype instance Fact C f = FactBase f\ntype instance Fact O f = f\n\n```", "```\ndata Insn e x where\n  Label  :: Label  ->                               Insn C O\n  Assign :: Var    -> Expr    ->                    Insn O O\n  Store  :: Expr   -> Expr    ->                    Insn O O\n  Branch :: Label  ->                               Insn O C\n  Cond   :: Expr   -> Label   -> Label  ->          Insn O C\n  Call   :: [Var]  -> String  -> [Expr] -> Label -> Insn O C\n  Return :: [Expr] ->                               Insn O C\n\n```", "```\nliveness' :: BwdTransfer Insn Live\nliveness' = mkBTransfer3 firstLive middleLive lastLive\n  where\n    firstLive :: Insn C O -> Live -> Live\n    firstLive (Label _) f = f\n\n    middleLive :: Insn O O -> Live -> Live\n    middleLive n@(Assign x _) f = addUses (S.delete x f) n\n    middleLive n@(Store _ _)  f = addUses f n\n\n    lastLive :: Insn O C -> FactBase Live -> Live\n    lastLive n@(Branch l)      f = addUses (fact f l) n\n    lastLive n@(Cond _ tl fl)  f = addUses (fact f tl `S.union` fact f fl) n\n    lastLive n@(Call vs _ _ l) f = addUses (fact f l `S.difference` S.fromList vs) n\n    lastLive n@(Return _)      _ = addUses (fact_bot liveLattice) n\n\n```", "```\n// a is live\nx = a;\n// a is not live\nfoo();\n// a is not live\na = 2;\n// a is live\ny = a;\n\n```", "```\nfold_EE :: (a -> Expr -> a) -> a -> Expr      -> a\nfold_EN :: (a -> Expr -> a) -> a -> Insn e x -> a\n\nfold_EE f z e@(Lit _)         = f z e\nfold_EE f z e@(Var _)         = f z e\nfold_EE f z e@(Load addr)     = f (f z addr) e\nfold_EE f z e@(Binop _ e1 e2) = f (f (f z e2) e1) e\n\nfold_EN _ z (Label _)       = z\nfold_EN f z (Assign _ e)    = f z e\nfold_EN f z (Store addr e)  = f (f z e) addr\nfold_EN _ z (Branch _)      = z\nfold_EN f z (Cond e _ _)    = f z e\nfold_EN f z (Call _ _ es _) = foldl f z es\nfold_EN f z (Return es)     = foldl f z es\n\n```", "```\naddUses :: S.Set Var -> Insn e x -> Live\naddUses s (Assign _ e)      = expr s e\naddUses s (Store e1 e2)     = expr (expr s e1) e2\naddUses s (Cond e _ _)      = expr s e\naddUses s (Call _ _ es _)   = foldl expr s es\naddUses s (Return es)       = foldl expr s es\naddUses s _                 = s\n\nexpr :: S.Set Var -> Expr -> Live\nexpr s e@(Load e') = addVar (addVar s e) e'\nexpr s e@(Binop _ e1 e2) = addVar (addVar (addVar s e) e1) e2\nexpr s e = addVar s e\n\n```", "```\nlastLive :: Insn O C -> FactBase Live -> Live\nlastLive n@(Branch l)      f = addUses (fact f l) n\nlastLive n@(Cond _ tl fl)  f = addUses (fact f tl `S.union` fact f fl) n\nlastLive n@(Call vs _ _ l) f = addUses (fact f l `S.difference` S.fromList vs) n\nlastLive n@(Return _)      _ = addUses (fact_bot liveLattice) n\n\n```", "```\n    f (x, y) {\n    L100:\n      goto L101\n    L101:\n      if x > 0 then goto L102 else goto L104\n    L102:\n      // z is not live here\n      (z) = f(x-1, y-1) goto L103\n    L103:\n      // z is live here\n      y = y + z\n      x = x - 1\n      goto L101\n    L104:\n      ret (y)\n    }\n\n    ```", "```\n-- Only interesting semantic choice: values of variables are live across\n-- a call site.\n-- Note that we don't need a case for x := y, where y holds a constant.\n-- We can write the simplest solution and rely on the interleaved optimization.\n--------------------------------------------------\n-- Analysis: variable equals a literal constant\nvarHasLit :: FwdTransfer Node ConstFact\nvarHasLit = mkFTransfer ft\n where\n  ft :: Node e x -> ConstFact -> Fact x ConstFact\n  ft (Label _)            f = f\n  ft (Assign x (Lit k))   f = Map.insert x (PElem k) f\n  ft (Assign x _)         f = Map.insert x Top f\n  ft (Store _ _)          f = f\n  ft (Branch l)           f = mapSingleton l f\n  ft (Cond (Var x) tl fl) f\n      = mkFactBase constLattice\n           [(tl, Map.insert x (PElem (Bool True))  f),\n            (fl, Map.insert x (PElem (Bool False)) f)]\n  ft (Cond _ tl fl) f\n      = mkFactBase constLattice [(tl, f), (fl, f)]\n  ft (Call vs _ _ bid)      f = mapSingleton bid (foldl toTop f vs)\n      where toTop f v = Map.insert v Top f\n  ft (Return _)             _ = mapEmpty\n\n```"]