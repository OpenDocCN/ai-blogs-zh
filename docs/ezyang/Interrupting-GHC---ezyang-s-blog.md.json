["```\n> {-# LANGUAGE ForeignFunctionInterface #-}\n> {-# LANGUAGE DeriveDataTypeable #-}\n> {-# LANGUAGE ScopedTypeVariables #-}\n>\n> import qualified Control.Exception as E\n>\n> import Foreign.C.Types (CInt)\n>\n> import Control.Monad\n> import Control.Concurrent (threadDelay, myThreadId, throwTo, forkIO)\n> import Control.Concurrent.MVar (newEmptyMVar, putMVar, readMVar)\n>\n> import System.IO (hPutStrLn, stderr)\n> import System.Posix.Signals (installHandler, sigINT, Handler(..))\n\n```", "```\n> fooHs :: Int -> IO Int\n> fooHs n = do\n>     putStrLn $ \"Arf HS \" ++ show n\n>     threadDelay 1000000\n>     fooHs n\n\n```", "```\n> reallySimpleInterruptible :: a -> IO a -> IO a\n> reallySimpleInterruptible defaultVal m = do\n>     let useDefault action =\n>             E.catch action\n>                 (\\(e :: E.AsyncException) ->\n>                     return $ case e of\n>                         E.UserInterrupt -> defaultVal\n>                         _ -> E.throw e\n>                         )\n>     useDefault m\n>\n> reallySimpleMain = do\n>     r <- reallySimpleInterruptible 42 (fooHs 1)\n>     putStrLn $ \"Finished with \" ++ show r\n\n```", "```\n> installIntHandler :: Handler -> IO Handler\n> installIntHandler h = installHandler sigINT h Nothing\n\n```", "```\n> simpleInterruptible :: a -> IO a -> IO a\n> simpleInterruptible defaultVal m = do\n>     tid <- myThreadId\n>     let install = installIntHandler (Catch ctrlc)\n>         ctrlc = do\n>             -- This runs in a different thread!\n>             hPutStrLn stderr \"Caught signal\"\n>             E.throwTo tid E.UserInterrupt\n>         cleanup oldHandler = installIntHandler oldHandler >> return ()\n>         useDefault action =\n>             E.catch action\n>                 (\\(e :: E.AsyncException) ->\n>                     return $ case e of\n>                         E.UserInterrupt -> defaultVal\n>                         _ -> E.throw e\n>                         )\n>     useDefault . E.bracket install cleanup $ const m\n>\n> simpleMain = do\n>     r <- simpleInterruptible 42 (fooHs 1)\n>     putStrLn $ \"Finished with \" ++ show r\n\n```", "```\n> foreign import ccall \"foo.h\" foo :: CInt -> IO ()\n\n```", "```\nvoid foo(int);\n\n```", "```\n#include <stdio.h>\n#include \"foo.h\"\n\nvoid foo(int d) {\n    while (1) {\n        printf(\"Arf C %d!\\n\", d);\n        sleep(1);\n    }\n}\n\n```", "```\nnat throwToMsg (Capability *cap, MessageThrowTo *msg)\n\n```", "```\ncase NotBlocked:\n{\n    if ((target->flags & TSO_BLOCKEX) == 0) {\n        // It's on our run queue and not blocking exceptions\n        raiseAsync(cap, target, msg->exception, rtsFalse, NULL);\n        return THROWTO_SUCCESS;\n    } else {\n        blockedThrowTo(cap,target,msg);\n        return THROWTO_BLOCKED;\n    }\n}\n\n```", "```\ncase BlockedOnCCall:\ncase BlockedOnCCall_NoUnblockExc:\n{\n    blockedThrowTo(cap,target,msg);\n    return THROWTO_BLOCKED;\n}\n\n```", "```\n   case BlockedOnCCall:\n   case BlockedOnCCall_NoUnblockExc:\n   {\n#ifdef THREADED_RTS\n       Task *task = NULL;\n       if (!target->bound) {\n           // walk all_tasks to find the correct worker thread\n           for (task = all_tasks; task != NULL; task = task->all_link) {\n               if (task->incall->suspended_tso == target) {\n                   break;\n               }\n           }\n           if (task != NULL) {\n               raiseAsync(cap, target, msg->exception, rtsFalse, NULL);\n               pthread_cancel(task->id);\n               task->cap = NULL;\n               task->stopped = rtsTrue;\n               return THROWTO_SUCCESS;\n           }\n       }\n#endif\n       blockedThrowTo(cap,target,msg);\n       return THROWTO_BLOCKED;\n   }\n\n```", "```\n> interruptible :: a -> IO a -> IO a\n> interruptible defaultVal m = do\n>     mresult <- newEmptyMVar -- transfer exception to caller\n>     mtid    <- newEmptyMVar\n>     let install = installIntHandler (Catch ctrlc)\n>         cleanup oldHandler = installIntHandler oldHandler >> return ()\n>         ctrlc = do\n>             hPutStrLn stderr \"Caught signal\"\n>             tid <- readMVar mtid\n>             throwTo tid E.UserInterrupt\n>         bracket = reportBracket . E.bracket install cleanup . const\n>         reportBracket action = do\n>             putMVar mresult =<< E.catches (liftM Right action)\n>                 [ E.Handler (\\(e :: E.AsyncException) ->\n>                     return $ case e of\n>                         E.UserInterrupt -> Right defaultVal\n>                         _ -> Left (E.toException e)\n>                     )\n>                 , E.Handler (\\(e :: E.SomeException) -> return (Left e))\n>                 ]\n>     putMVar mtid =<< forkIO (bracket m)\n>     either E.throw return =<< readMVar mresult -- one write only\n>\n> main = main' 3\n>\n> main' 0 = putStrLn \"Quitting\"\n> main' n = do\n>     interruptible () $ do\n>         (r :: Either E.AsyncException ()) <- E.try $ foo n\n>         putStrLn $ \"Thread \" ++ show n ++ \" was able to catch exception\"\n>     main' (pred n)\n\n```", "```\nArf C 3!\nArf C 3!\n^CCaught signal\nThread 3 was able to catch exception\nArf C 2!\nArf C 2!\nArf C 2!\n^CCaught signal\nThread 2 was able to catch exception\nArf C 1!\nArf C 1!\n^CCaught signal\nThread 1 was able to catch exception\nQuitting\n\n```"]