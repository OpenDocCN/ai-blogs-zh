- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-07-01 18:17:57'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: 'Type Technology Tree : ezyang’s blog'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[http://blog.ezyang.com/2011/03/type-tech-tree/](http://blog.ezyang.com/2011/03/type-tech-tree/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Type Technology Tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'They say that one doesn’t discover advanced type system extensions: rather,
    the type system extensions discover you! Nevertheless, it’s worthwhile to know
    what the tech tree for GHC’s type extensions are, so you can decide how much power
    (and the correspondingly headache inducing error messages) you need. I’ve organized
    the relations in the following diagram with the following criterion in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: Some extensions automatically enable other extensions (implies);
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Some extensions offer all the features another extension offers (subsumes);
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Some extensions work really nicely with other extensions (synergy);
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Some extensions offer equivalent (but differently formulated) functionality
    to another extension (equiv).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It’s also worth noting that the GHC manual divides these extensions into “Extensions
    to data types and type synonyms”, “Class and instances declarations”, “Type families”
    and “Other type system extensions”. I have them organized here a little differently.
  prefs: []
  type: TYPE_NORMAL
- en: Rank and data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our first tech tree brings together two extensions: arbitrary-rank polymorphism
    and generalized algebraic data types.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Briefly:'
  prefs: []
  type: TYPE_NORMAL
- en: 'GADTSyntax permits ordinary data types to be written GADT-style (with explicit
    constructor signatures): `data C where C :: Int -> C`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ExplicitForall](http://hackage.haskell.org/trac/haskell-prime/wiki/ExplicitForall)
    allows you to explicitly state the quantifiers in polymorphic types: `forall a.
    a -> a`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ExistentialQuantification](http://hackage.haskell.org/trac/haskell-prime/wiki/ExistentialQuantification)
    allows types to be hidden inside a data constructor: `data C = forall e. C e`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[GADTs](http://hackage.haskell.org/trac/haskell-prime/wiki/GADTs) permits explicit
    constructor signatures: `data C where C :: C a -> C b -> C (a, b)`. Subsumes ExistentialQuantification
    because existentially quantified data types are simply polymorphic constructors
    for which the type variable isn’t in the result.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PolymorphicComponents](http://hackage.haskell.org/trac/haskell-prime/wiki/PolymorphicComponents)
    allows you to write `forall` inside data type fields: `data C = C (forall a. a)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Rank2Types](http://hackage.haskell.org/trac/haskell-prime/wiki/Rank2Types)
    allows polymorphic arguments: `f :: (forall a. a -> a) -> Int -> Int`. This with
    GADTs subsumes PolymorphicComponents because data type fields with `forall` within
    them correspond to data constructors with rank-2 types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[RankNTypes](http://hackage.haskell.org/trac/haskell-prime/wiki/RankNTypes):
    `f :: Int -> (forall a. a -> a)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ImpredicativeTypes allows polymorphic functions and data structures to be parametrized
    over polymorphic types: `Maybe (forall a. a -> a)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instances
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our next tech tree deals with type class instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'Briefly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[TypeSynonymInstances](http://hackage.haskell.org/trac/haskell-prime/wiki/TypeSynonymInstances)
    permits macro-like usage of type synonyms in instance declarations: `instance
    X String`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[FlexibleInstances](http://hackage.haskell.org/trac/haskell-prime/wiki/FlexibleInstances)
    allows more instances for more interesting type expressions, with restrictions
    to preserve decidability: `instance MArray (STArray s) e (ST s)` (frequently seen
    with multi-parameter type classes, which are not in the diagram)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[UndecidableInstances](http://hackage.haskell.org/trac/haskell-prime/wiki/UndecidableInstances)
    allows instances for more interesting type expression with no restrictions, at
    the cost of decidability. See [Oleg](http://okmij.org/ftp/Haskell/types.html#undecidable-inst-defense)
    for a legitimate example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[FlexibleContexts](http://hackage.haskell.org/trac/haskell-prime/wiki/FlexibleContexts)
    allows more type expressions in constraints of functions and instance declarations:
    `g :: (C [a], D (a -> b)) => [a] -> b`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[OverlappingInstances](http://hackage.haskell.org/trac/haskell-prime/wiki/OverlappingInstances)
    allows instances to overlap if there is a most specific one: `instance C a; instance
    C Int`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[IncoherentInstances](http://hackage.haskell.org/trac/haskell-prime/wiki/IncoherentInstances)
    allows instances to overlap arbitrarily.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perhaps conspicuously missing from this diagram is `MultiParamTypeClasses` which
    is below.
  prefs: []
  type: TYPE_NORMAL
- en: Type families and functional dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our final tech tree addresses programming with types:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Briefly:'
  prefs: []
  type: TYPE_NORMAL
- en: 'KindSignatures permits stating the kind of a type variable: `m :: * -> *`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[MultiParamTypeClasses](http://hackage.haskell.org/trac/haskell-prime/wiki/MultiParamTypeClasses)
    allow type classes to range over multiple type variables: `class C a b`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[FunDeps](http://hackage.haskell.org/trac/haskell-prime/wiki/FunctionalDependencies)
    allow restricting instances of multi-parameter type classes, helping resolve ambiguity:
    `class C a b | a -> b`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[TypeFamilies](http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/type-families.html)
    allow “functions” on types: `data family Array e`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The correspondence between functional dependencies and type families is well
    known, though not perfect (type families can be more wordy and can’t express certain
    equalities, but play more nicely with GADTs).
  prefs: []
  type: TYPE_NORMAL
