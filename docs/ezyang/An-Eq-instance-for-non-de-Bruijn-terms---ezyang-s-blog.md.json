["```\ntype Var = Int\ndata Expr = Var Var\n          | App Expr Expr\n          | Lam Var Expr\n\n```", "```\ninstance Eq Expr where\n  Var v == Var v'          = n == n'\n  App e1 e2 == App e1' e2' = e1 == e1' && e2 == e2'\n  Lam v e == Lam v' e'     = _what_goes_here\n\n```", "```\neqTypeX :: RnEnv2 -> Type -> Type -> Bool\n\n```", "```\nimport qualified Data.Map as Map\nimport Data.Map (Map)\n\ndata DeBruijnExpr = D Expr NEnv\n\ntype Level = Int\ndata NEnv = N Level (Map Var Level)\n\nlookupN :: Var -> NEnv -> Maybe Level\nlookupN v (N _ m) = Map.lookup v m\n\nextendN :: Var -> NEnv -> NEnv\nextendN v (N i m) = N (i+1) (Map.insert v i m)\n\n```", "```\ninstance Eq DeBruijnExpr where\n  D (Var v) n == D (Var v') n' =\n    case (lookupN v n, lookupN v' n') of\n      (Just l, Just l')  -> l == l'\n      (Nothing, Nothing) -> v == v'\n      _ -> False\n  D (App e1 e2) n == D (App e1' e2') n' =\n    D e1 n == D e1' n' && D e2 n == D e2' n'\n  D (Lam v e) n == D (Lam v' e') n' =\n    D e (extendN v n) == D e' (extendN v' n')\n\n```", "```\n> data DeBruijnExpr' = Var' Var\n>                    | Bound' Level\n>                    | Lam' DeBruijnExpr'\n>                    | App' DeBruijnExpr' DeBruijnExpr'\n> \n> ```"]