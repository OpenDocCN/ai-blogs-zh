["```\n(* Coq *)\n\n```", "```\n{- Haskell -}\n\n```", "```\nDefinition f x := x + x.\n\n```", "```\nf x = x + x\n\n```", "```\nfun x => x + x\n\n```", "```\n\\x -> x + x\n\n```", "```\n    Definition Endo A := A -> A.\n\n    ```", "```\n    type Endo a = a -> a\n\n    ```", "```\n    Inductive fcode :=\n      | intcode : fcode\n      | anycode : fcode.\n    Definition interp (c : fcode) : Type := match c with\n      | intcode -> bool\n      | anycode -> char\n    end.\n\n    ```", "```\n    type family F a where\n      F Int = Bool\n      F a   = Char\n\n    ```", "```\n    (* Not directly supported in Coq *)\n\n    ```", "```\n    type family F a\n    type instance F Int = Char\n    type instance F Char = Int\n\n    ```", "```\nDefinition id : forall (A : Type), A -> A := fun A => fun x => x.\n\n```", "```\nid :: a -> a\nid = \\x -> x\n\n```", "```\nid :: forall a. a -> a\n\n```", "```\nDefinition f : (forall A, A -> A) -> bool := fun g => g bool true.\n\n```", "```\nf :: (forall a. a -> a) -> Bool\nf g = g True\n\n```", "```\n(true, false) : bool * bool\n(True, False) :: (Bool, Bool)\n\n```", "```\ntt : unit\n() :: ()\n\n```", "```\nmatch p with\n  | (x, y) => ...\nend\n\n```", "```\ncase p of\n  (x, y) -> ...\n\n```", "```\nDefinition p := exist bool not : { A : Type & A -> bool }\n\n```", "```\ndata Ex = forall a. Ex (a -> Bool)\np = Ex not\n\n```", "```\nInductive bool : Type :=\n  | true : bool\n  | false : bool.\n\n```", "```\ndata Bool :: * where\n  True :: Bool\n  False :: Bool\n\n```", "```\nInductive nat : Type :=\n  | z : nat\n  | s : nat -> nat.\n\n```", "```\ndata Nat :: * where\n  Z :: Nat\n  S :: Nat -> Nat\n\n```", "```\nInductive vec (A : Type) : nat -> Type :=\n  | vnil  : vec A 0\n  | vcons : forall n, A -> vec A n -> vec A (S n)\n\n```", "```\ndata Vec :: Nat -> * -> * where\n  VNil  :: Vec Z a\n  VCons :: a -> Vec n a -> Vec (S n) a\n\n```", "```\ndata Free f a where\n   Free :: f (Free f a) -> Free f a\n   Pure :: a -> Free f a\n\ndata Mu f where\n   Roll :: f (Mu f) -> Mu f\n\n```"]