["```\ndo { x <- ask; ... }\nlet x = ask\n\n```", "```\nmain = (`runReaderT` (2 :: Int)) $ do\n  x <- ask\n  let m = ask\n  liftIO $ print x\n  m3 <- local (const 3) $ do\n    liftIO $ print x\n    y <- m\n    liftIO $ print y\n    let m2 = ask\n    return m2\n  z <- m3\n  liftIO $ print z\n\n```", "```\n2\n2\n3\n2\n\n```", "```\n(define (eval exp env)\n  (cond ((self-evaluating? exp) exp)\n        ((variable? exp) (lookup-variable-value exp env))\n        ((lambda? exp)\n         (make-procedure (lambda-parameters exp)\n                         (lambda-body exp)))\n        ((application? exp)\n         (apply (eval (operator exp) env)\n                (list-of-values (operands exp) env))\n                env)\n        ))\n(define (apply procedure arguments env)\n  (eval\n    (procedure-body procedure)\n    (extend-environment\n      (procedure-parameters procedure)\n      arguments\n      env)))\n\n```", "```\n(define (eval exp env)\n  (cond ((self-evaluating? exp) exp)\n        ((variable? exp) (lookup-variable-value exp env))\n        ((lambda? exp)\n         (make-procedure (lambda-parameters exp)\n                         (lambda-body exp)\n                         env))\n        ((application? exp)\n         (apply (eval (operator exp) env)\n                (list-of-values (operands exp) env)))\n        ))\n(define (apply procedure arguments)\n  (eval\n    (procedure-body procedure)\n    (extend-environment\n      (procedure-parameters procedure)\n      arguments\n      (procedure-environment procedure))))\n\n```", "```\nmain = do\n  let ?x = 2 :: Int\n  let x = ?x\n      m = ?x\n  ...\n\n```", "```\nmain =\n  let ?x = 2 :: Int\n  in let x :: Int\n         x = ?x\n         m :: (?x :: Int) => Int\n         m = ?x\n     in let ?x = 3 :: Int\n        in print (x, m)\n\n```", "```\nmain =\n  let ?x = (2 :: Int)\n  in do m3 <- let x :: Int\n                  x = ?x\n                  m :: (?x :: Int) => Int\n                  m = ?x\n              in let ?x = 3\n                 in let m2 :: (?x :: Int) => Int\n                        m2 = ?x\n                    in print (x, m) >> return m2\n        print m3\n\n```", "```\nf :: (?x :: Int) => Int\nf = g\n\ng :: Int\ng = let ?x = 2 in h\n\nh :: (?x :: Int) => Int\nh = ?x\n\n```", "```\nmain =\n  let ?x = (2 :: Int)\n  in let f2 :: (?x :: Int) => () -> Int\n         f2 = let ?x = 3\n              in let f1 :: (?x :: Int) => () -> Int\n                     f1 = \\() -> ?x\n                 in f1\n     in print (f2 ())\n\n```", "```\nmain =\n  let ?x = (2 :: Int)\n  in let f2 :: () -> (?x :: Int) => Int\n         f2 = let ?x = (3 :: Int)\n              in let f1 :: () -> (?x :: Int) => Int\n                     f1 = \\() -> ?x\n                 in f1\n     in print (f2 ())\n\n```", "```\n{-# LANGUAGE ImplicitParams, NoMonomorphismRestriction,\n   MultiParamTypeClasses, FlexibleInstances #-}\n\nimport Control.Monad\nimport Control.Monad.Reader\n\n-- How the API looks\n\nf = (`runReaderT` (2 :: Int)) $ do\n    l1 <- label\n    let ?f = l1\n    r1 <- askl ?f\n    liftIO $ print r1\n    g\n\ng = (`runReaderT` (3 :: Int)) $ do\n    l <- label\n    let ?g = l\n    r1 <- askl ?f\n    r2 <- askl ?g\n    liftIO $ print r1\n    liftIO $ print r2\n    delay <- h\n    -- change our environment before running request\n    local (const 8) $ do\n        r <- delay\n        liftIO $ print r\n\nh = (`runReaderT` (4 :: Int)) $ do\n    l3 <- label\n    let ?h = l3\n    r1 <- askl ?f\n    r2 <- askl ?g\n    r3 <- askl ?h\n    -- save a delayed request to the environment of g\n    let delay = askl ?g\n    liftIO $ print r1\n    liftIO $ print r2\n    liftIO $ print r3\n    return delay\n\n-- How the API is implemented\n\nlabel :: Monad m => m (m ())\nlabel = return (return ())\n\nclass (Monad m1, Monad m2) => LiftReader r1 m1 m2 where\n    askl :: ReaderT r1 m1 () -> m2 r1\n\ninstance (Monad m) => LiftReader r m (ReaderT r m) where\n    askl _ = ask\n\ninstance (Monad m) => LiftReader r m (ReaderT r1 (ReaderT r m)) where\n    askl = lift . askl\n\ninstance (Monad m) => LiftReader r m (ReaderT r2 (ReaderT r1 (ReaderT r m))) where\n    askl = lift . askl\n\n```", "```\n*Main> f\n2\n2\n3\n2\n3\n4\n8\n\n```"]