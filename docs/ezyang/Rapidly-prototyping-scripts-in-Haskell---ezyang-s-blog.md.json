["```\nInferred type: lookupKey :: forall a.\n                            [Char] -> [([Char], [a])] -> [a]\n\nInferred type: lookupKey1 :: forall a.\n                             [Char] -> [([Char], [a])] -> Maybe a\n\n```", "```\nInferred type: mungeAgreement :: forall (m :: * -> *).\n                                 (Monad m) =>\n                                 LDAPEntry -> m LDAPEntry\n\nInferred type: replicaConfigPredicate :: forall t (m :: * -> *).\n                                         (Monad m) =>\n                                         ([Char], t) -> m Bool\n\n```", "```\nInferred type: tryAll :: forall a. [IO a] -> IO a\n\n```", "```\nInferred type: debugIOVal :: forall b. [Char] -> IO b -> IO b\n\n```", "```\nldapAddEntry ldap (LDAPEntry dn attrs) = ...\nldapDeleteEntry ldap (LDAPEntry dn _ ) = ...\nprintAgreements ldap = ...\nsuspendAgreements ldap statefile = ...\nrestoreAgreements ldap statefile = ...\nreinitAgreements ldap statefile = ...\n\n```", "```\nwithFile statefile WriteMode $ \\h ->\n    hPutStr h (serializeEntries replicas)\n\nforM_ conflicts $ \\(LDAPEntry dn attrs) ->\n    putStrLn dn\n\n```", "```\n    case mhost of\n        (Just host) -> do\n            let status = maybe \"no status found\" id mstatus\n            printf (\"%-\" ++ show width ++ \"s : %s\\n\") host status\n        _ -> warnIO (\"Malformed replication agreement at \" ++ dn)\n\n    ```", "```\n    let section = takeWhile (not . isPrefixOf \"profile\") . tail\n                . dropWhile (/= \"profile default\") $ contents\n        getField name = let prefix = name ++ \" \"\n                        in evaluate . fromJust . stripPrefix prefix\n                                    . fromJust . find (isPrefixOf prefix)\n                                    $ section\n\n    ```"]