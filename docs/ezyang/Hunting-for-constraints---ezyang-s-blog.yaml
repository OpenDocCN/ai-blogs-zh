- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-07-01 18:18:27'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: 'Hunting for constraints : ezyang’s blog'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[http://blog.ezyang.com/2010/02/hunting-for-constraints/](http://blog.ezyang.com/2010/02/hunting-for-constraints/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following question appeared as part of a [numbers-based puzzle](http://www.mit.edu/~puzzle/10/puzzles/2010/fun_with_numbers/)
    in the [2010 MIT Mystery Hunt](http://www.mit.edu/~puzzle/10/):'
  prefs: []
  type: TYPE_NORMAL
- en: His final level on [Wizard of Wor](http://hackage.haskell.org/package/dow) was
    equal to the smallest number that can be written as the sum of 4 non-zero squares
    in exactly 9 ways
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: I'd like to explore constraint search in Haskell to solve this problem. The
    hope is to find a (search) program that directly reflects the problem as posed,
    and also gives us an answer!
  prefs: []
  type: TYPE_NORMAL
- en: Because we are looking for the smallest number, it makes sense to start testing
    from a small number and start counting up. We'll assume that the answer to this
    question won't overflow Int.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to test if it can be written as the sum of 4 non-zero squares in
    exactly 9 ways. This problem reduces to "how many ways can n be written as the
    sum of squares", which is another search problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll assume that 4+1+1+1 and 1+4+1+1 don''t constitute distinct for the purposes
    of our nine squares. This results in the first piece of cleverness: if we impose
    a strict ordering on our squares, we once again get uniqueness.'
  prefs: []
  type: TYPE_NORMAL
- en: We also need to bound our search space; while fair search can help to some degree
    with infinite failure, our implementation will be much simpler if we can do some
    early termination. A very simple condition to terminate on is if the sum of the
    squares exceeds the number we're looking for.
  prefs: []
  type: TYPE_NORMAL
- en: Considering the case where we are matching for x, and we have candidate roots
    a, b and c. Then, the maximum the remaining square can be is x - a^2 - b^2 - c^2,
    and the maximum value for d is the floor of the square root. Square roots are
    cheap, and we're using machine size integers, so things are good.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'From there, we just write out the search for distinct sums of squares of a
    number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'And from there, the solution falls out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We cleverly use `[0..]` so that the index is the same as the number itself.
    Alternative methods might use tuples.
  prefs: []
  type: TYPE_NORMAL
