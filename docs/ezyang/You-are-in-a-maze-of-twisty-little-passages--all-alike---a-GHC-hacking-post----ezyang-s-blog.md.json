["```\ncd ghc-clean\n./darcs-all get\n./darcs-all pull -a\ncd ../ghc-build\nlndir ../ghc-clean\nperl boot && ./configure && make\ninplace/bin/ghc-stage2 --interactive\n\n```", "```\nezyang@javelin:~/Dev/ghc-build/testsuite/tests/ghc-regress/ffi/should_run$ ./cleanupThreads\n203\n\n```", "```\nb75006d0: allocated 1 capabilities\nb75006d0: new task (taskCount: 1)\nb75006d0: returning; I want capability 0\nb75006d0: resuming capability 0\nb75006d0: starting new worker on capability 0\nb75006d0: new worker task (taskCount: 2)\nb75006d0: task exiting\nb75006d0: new task (taskCount: 2)\nb75006d0: returning; I want capability 0\nb71ffb70: cap 0: schedule()\nb71ffb70: giving up capability 0\n\n```", "```\nb75006d0: cap 0: created thread 1\nb75006d0: cap 0: thread 1 appended to run queue\nb75006d0: new bound thread (1)\nb75006d0: cap 0: schedule()\nb75006d0: cap 0: running thread 1 (ThreadRunGHC)\nb75006d0: cap 0: thread 1 stopped (suspended while making a foreign call)\nb75006d0: freeing capability 0\nb75006d0: returning; I want capability 0\nb75006d0: resuming capability 0\nb75006d0: cap 0: running thread 1 (ThreadRunGHC)\nb75006d0: cap 0: thread 1 stopped (suspended while making a foreign call)\nb75006d0: freeing capability 0\nb75006d0: returning; I want capability 0\nb75006d0: resuming capability 0\nb75006d0: cap 0: running thread 1 (ThreadRunGHC)\nb75006d0: cap 0: created thread 2\nb75006d0: cap 0: thread 2 appended to run queue\nb75006d0: cap 0: thread 1 stopped (finished)\n\n```", "```\nb75006d0: woken up on capability 0\nb75006d0: resuming capability 0\nb75006d0: cap 0: running thread 3 (ThreadRunGHC)\nb75006d0: cap 0: created thread 4\nb75006d0: cap 0: thread 4 appended to run queue\nb75006d0: cap 0: created thread 5\nb75006d0: cap 0: thread 5 appended to run queue\nb75006d0: cap 0: created thread 6\nb75006d0: cap 0: thread 6 appended to run queue\nb75006d0: cap 0: created thread 7\nb75006d0: cap 0: thread 7 appended to run queue\nb75006d0: cap 0: created thread 8\nb75006d0: cap 0: thread 8 appended to run queue\nb75006d0: cap 0: created thread 9\nb75006d0: cap 0: thread 9 appended to run queue\nb75006d0: cap 0: created thread 10\nb75006d0: cap 0: thread 10 appended to run queue\nb75006d0: cap 0: created thread 11\nb75006d0: cap 0: thread 11 appended to run queue\nb75006d0: cap 0: created thread 12\nb75006d0: cap 0: thread 12 appended to run queue\nb75006d0: cap 0: created thread 13\n\n```", "```\n54139b70: starting new worker on capability 0\n54139b70: new worker task (taskCount: 201)\n53938b70: cap 0: schedule()\n53938b70: cap 0: running thread 202 (ThreadRunGHC)\n53938b70: cap 0: thread 202 stopped (suspended while making a foreign call)\n53938b70: starting new worker on capability 0\n53938b70: new worker task (taskCount: 202)\n53137b70: cap 0: schedule()\n53137b70: cap 0: running thread 203 (ThreadRunGHC)\n53137b70: cap 0: thread 203 stopped (suspended while making a foreign call)\n53137b70: starting new worker on capability 0\n53137b70: new worker task (taskCount: 203)\n52936b70: cap 0: schedule()\n\n```", "```\n   52936b70: woken up on capability 0\n   52936b70: resuming capability 0\n   52936b70: deadlocked, forcing major GC...\n   52936b70: cap 0: requesting parallel GC\n   52936b70: ready_to_gc, grabbing GC threads\nall threads:\nthreads on capability 0:\nother threads:\n       thread  203 @ 0xb72b5c00 is blocked on an external call (TSO_DIRTY)\n       thread  202 @ 0xb72b5800 is blocked on an external call (TSO_DIRTY)\n       thread  201 @ 0xb72b5400 is blocked on an external call (TSO_DIRTY)\n       thread  200 @ 0xb72b5000 is blocked on an external call (TSO_DIRTY)\n       thread  199 @ 0xb72b4c00 is blocked on an external call (TSO_DIRTY)\n       thread  198 @ 0xb72b4800 is blocked on an external call (TSO_DIRTY)\n       thread  197 @ 0xb72b4400 is blocked on an external call (TSO_DIRTY)\n       thread  196 @ 0xb72b4000 is blocked on an external call (TSO_DIRTY)\n       thread  195 @ 0xb72b3c00 is blocked on an external call (TSO_DIRTY)\n       thread  194 @ 0xb72b3800 is blocked on an external call (TSO_DIRTY)\n       thread  193 @ 0xb72b3400 is blocked on an external call (TSO_DIRTY)\n       [snip (you get the idea)]\n\n```", "```\nb69feb70: cap 0: running thread 4 (ThreadRunGHC)\nb69feb70: cap 0: waking up thread 3 on cap 0\nb69feb70: cap 0: thread 3 appended to run queue\nb69feb70: cap 0: thread 4 stopped (finished)\nb69feb70: giving up capability 0\nb69feb70: there are 2 spare workers\nb69feb70: passing capability 0 to bound task 0xb75006d0\nb61fdb70: returning; I want capability 0\nb61fdb70: resuming capability 0\nb61fdb70: cap 0: running thread 5 (ThreadRunGHC)\nb59fcb70: returning; I want capability 0\nb61fdb70: cap 0: thread 5 stopped (finished)\nb61fdb70: giving up capability 0\nb61fdb70: there are 3 spare workers\nb61fdb70: passing capability 0 to worker 0xb59fcb70\nb75006d0: woken up on capability 0\nb75006d0: capability 0 is owned by another task\nb51fbb70: returning; I want capability 0\nb59fcb70: resuming capability 0\nb59fcb70: cap 0: running thread 6 (ThreadRunGHC)\nb59fcb70: cap 0: thread 6 stopped (finished)\nb59fcb70: giving up capability 0\nb49fab70: returning; I want capability 0\nb59fcb70: there are 4 spare workers\nb59fcb70: passing capability 0 to worker 0xb51fbb70\nb51fbb70: resuming capability 0\nb51fbb70: cap 0: running thread 7 (ThreadRunGHC)\nb51fbb70: cap 0: thread 7 stopped (finished)\nb51fbb70: giving up capability 0\nb41f9b70: returning; I want capability 0\nb51fbb70: there are 5 spare workers\n\n```", "```\nb61fdb70: cap 0: thread 5 stopped (finished)\nb61fdb70: giving up capability 0\n\n```", "```\nezyang@javelin:~/Dev/ghc-clean/rts$ grep -R stopped .\n./Capability.c:    // list of this Capability.  A worker can mark itself as stopped,\n./Capability.c:    if (!isBoundTask(task) && !task->stopped) {\n./RaiseAsync.c:     - all the other threads in the system are stopped (eg. during GC).\n./RaiseAsync.c:    // if we got here, then we stopped at stop_here\n./Task.c:        if (task->stopped) {\n./Task.c:    task->stopped       = rtsFalse;\n./Task.c:    task->stopped = rtsFalse;\n./Task.c:    task->stopped = rtsTrue;\n./Task.c:    task->stopped = rtsTrue;\n./Task.c:   debugBelch(\"task %p is %s, \", taskId(task), task->stopped ? \"stopped\" : \"alive\");\n./Task.c:   if (!task->stopped) {\n./sm/GC.c:      // The other threads are now stopped.  We might recurse back to\n./Schedule.c:                  \"--<< thread %ld (%s) stopped: requesting a large block (size %ld)\\n\",\n./Schedule.c:                  \"--<< thread %ld (%s) stopped to switch evaluators\",\n./Schedule.c:       // stopped.  We need to stop all Haskell threads, including\n./Trace.c:        debugBelch(\"cap %d: thread %lu stopped (%s)\\n\",   ### THIS IS THE ONE\n./Task.h:    rtsBool    stopped;         // this task has stopped or exited Haskell\n./Task.h:// Notify the task manager that a task has stopped.  This is used\n./Task.h:// Put the task back on the free list, mark it stopped.  Used by\n./Interpreter.c:                  // already stopped at just now\n./Interpreter.c:            // record that this thread is not stopped at a breakpoint anymore\n./win32/Ticker.c:            // it still hasn't stopped.\n\n```", "```\ncase EVENT_STOP_THREAD:     // (cap, thread, status)\n    debugBelch(\"cap %d: thread %lu stopped (%s)\\n\",Â·\n               cap->no, (lnat)tso->id, thread_stop_reasons[other]);\n    break;\n\n```", "```\nezyang@javelin:~/Dev/ghc-clean/rts$ grep -R EVENT_STOP_THREAD .\n./Trace.c:    case EVENT_STOP_THREAD:     // (cap, thread, status)\n./eventlog/EventLog.c:  [EVENT_STOP_THREAD]         = \"Stop thread\",\n./eventlog/EventLog.c:        case EVENT_STOP_THREAD:     // (cap, thread, status)\n./eventlog/EventLog.c:    case EVENT_STOP_THREAD:     // (cap, thread, status)\n./Trace.h:    HASKELLEVENT_STOP_THREAD(cap, tid, status)\n./Trace.h:    traceSchedEvent(cap, EVENT_STOP_THREAD, tso, status);\n\n```", "```\nINLINE_HEADER void traceEventStopThread(Capability          *cap    STG_UNUSED,\n                                        StgTSO              *tso    STG_UNUSED,\n                                        StgThreadReturnCode  status STG_UNUSED)\n{\n    traceSchedEvent(cap, EVENT_STOP_THREAD, tso, status);\n    dtraceStopThread((EventCapNo)cap->no, (EventThreadID)tso->id,\n                     (EventThreadStatus)status);\n}\n\n```", "```\nezyang@javelin:~/Dev/ghc-clean/rts$ grep -R traceEventStopThread .\n./Schedule.c:    traceEventStopThread(cap, t, ret);\n./Schedule.c:  traceEventStopThread(cap, tso, THREAD_SUSPENDED_FOREIGN_CALL);\n./Trace.h:INLINE_HEADER void traceEventStopThread(Capability          *cap    STG_UNUSED,\n\n```", "```\nscheduleYield(&cap,task);\n\nif (emptyRunQueue(cap)) continue; // look for work again\n\n// Get a thread to run\nt = popRunQueue(cap);\n\n```", "```\ndebugTrace(DEBUG_sched, \"giving up capability %d\", cap->no);\n\n// We must now release the capability and wait to be woken up\n// again.\ntask->wakeup = rtsFalse;\nreleaseCapabilityAndQueueWorker(cap);\n\n```", "```\nstatic void\nreleaseCapabilityAndQueueWorker (Capability* cap USED_IF_THREADS)\n{\n    Task *task;\n\n    ACQUIRE_LOCK(&cap->lock);\n\n    task = cap->running_task;\n\n    // If the current task is a worker, save it on the spare_workers\n    // list of this Capability.  A worker can mark itself as stopped,\n    // in which case it is not replaced on the spare_worker queue.\n    // This happens when the system is shutting down (see\n    // Schedule.c:workerStart()).\n    if (!isBoundTask(task) && !task->stopped) {\n       task->next = cap->spare_workers;\n       cap->spare_workers = task;\n    }\n    // Bound tasks just float around attached to their TSOs.\n\n    releaseCapability_(cap,rtsFalse);\n\n    RELEASE_LOCK(&cap->lock);\n}\n\n```", "```\nint i;\nTask *t;\nfor (i = 0, t = cap->spare_workers; t != NULL; t = t->next, i++) {}\ndebugTrace(DEUBG_sched, \"there are %d spare workers\", i);\n\n```", "```\n54139b70: there are 199 spare workers\n54139b70: passing capability 0 to worker 0x53938b70\n53938b70: resuming capability 0\n53938b70: cap 0: running thread 202 (ThreadRunGHC)\n53938b70: cap 0: thread 202 stopped (blocked)\n    thread  202 @ 0xb727a400 is blocked on an MVar @ 0xb72388a8 (TSO_DIRTY)\n53938b70: giving up capability 0\n53938b70: there are 200 spare workers\n53938b70: passing capability 0 to worker 0x53137b70\n53137b70: resuming capability 0\n53137b70: cap 0: running thread 203 (ThreadRunGHC)\n53137b70: cap 0: thread 203 stopped (blocked)\n    thread  203 @ 0xb727a000 is blocked on an MVar @ 0xb72388a8 (TSO_DIRTY)\n53137b70: giving up capability 0\n53137b70: there are 201 spare workers\n\n```", "```\nfor (i = 1; t != NULL && i < 6; t = t->next, i++) {}\nif (i >= 6) {\n        debugTrace(DEBUG_sched, \"Lots of spare workers hanging around, terminating this thread\");\n        releaseCapability_(cap,rtsFalse);\n        RELEASE_LOCK(&cap->lock);\n        pthread_exit(NULL);\n}\n\n```", "```\nezyang@javelin:~/Dev/ghc-build/testsuite/tests/ghc-regress/ffi/should_run$ ./cleanupThreads\n7\n\n```"]