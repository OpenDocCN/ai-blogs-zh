- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-07-01 18:18:13'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: 'Delaying implicit parameter binding : ezyang’s blog'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[http://blog.ezyang.com/2010/07/delaying-implicit-parameter-binding/](http://blog.ezyang.com/2010/07/delaying-implicit-parameter-binding/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Today, we talk in more detail at some points about dynamic binding that Dan
    Doel brought up in the comments of [Monday’s post](http://blog.ezyang.com/2010/07/implicit-parameters-in-haskell/).
    Our first step is to solidify our definition of dynamic binding as seen in a lazy
    language (Haskell, using the Reader monad) and in a strict language (Scheme, using
    a buggy meta-circular evaluator). We then come back to implicit parameters, and
    ask the question: do implicit parameters perform dynamic binding? (Disregarding
    the monomorphism restriction, [Oleg says no](http://okmij.org/ftp/Computation/dynamic-binding.html#implicit-parameter-neq-dynvar),
    but with a [possible bug in GHC](http://hackage.haskell.org/trac/ghc/ticket/4226)
    the answer is yes.) And finally, we show how to combine the convenience of implicit
    parameters with the explicitness of the Reader monad using a standard trick that
    Oleg uses in his monadic regions.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Aside.* For those of you with short attention span, the gist is this: the
    type of an expression that uses an implicit parameter determines when the binding
    for the implicit parameter gets resolved. For most projects, implicit parameters
    will tend to get resolved as soon as possible, which isn’t very dynamic; turning
    off the monomorphism restriction will result in much more dynamic behavior. You
    won’t see very many differences if you only set your implicit parameters once
    and don’t touch them again.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'At risk of sounding like a broken record, I would like to review an important
    distinction about the Reader monad. In the Reader monad, there is a great difference
    between the following two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If we are in the `Reader r` monad, the first `x` would have the type `r`, while
    the second `x` would have the type `Reader r r`; one might call the second `x`
    “delayed”, because we haven’t used `>>=` to peek into the proverbial monad wrapper
    and act on its result. We can see what is meant by this in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'which outputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Though we changed the underlying environment with the call to `local`, the original
    `x` stayed unchanged, while when we forced the value of `m` into `y`, we found
    the new environment. `m2` acted analogously, though in the reverse direction (declared
    in the inner `ReaderT`, but took on the outer `ReaderT` value). The semantics
    are different, and the syntax is different accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Please keep this in mind, as we are about to leave the (dare I say “familiar”?)
    world of monads to the lands of Lisp, where most code is *not* monadic, where
    dynamic binding was accidentally invented.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, I have the pared-down version of the metacircular evaluator found in
    SICP (with mutation and sequencing ripped out; the [theory is sound](http://okmij.org/ftp/Computation/dynamic-binding.html#DDBinding)
    if these are added in but we’re ignoring them for the purpose of this post):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s another version of the evaluator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If your SICP knowledge is a little rusty, before [consulting the source](http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-26.html#%_sec_4.1),
    try to figure out which version implements lexical scoping, and which version
    implements dynamic scoping.
  prefs: []
  type: TYPE_NORMAL
- en: 'The principal difference between these two versions lie in the definition of
    `make-procedure`. The first version is essentially a verbatim copy of the lambda
    definition, taking only the parameters and body, while the second adds an extra
    bit of information, the environment at the time the lambda was made. Conversely,
    when `apply` unpacks the procedure to run its innards, the first version needs
    some extra information—the current environment—to serve as basis for the environment
    that we will run `eval` with, while the second version just uses the environment
    it tucked away in the procedure. For a student who has not had the “double-bubble”
    lambda-model beaten into their head, both choices seem plausible, and they would
    probably just go along with the definition of `make-procedure` (nota bene: giving
    students an incorrect `make-procedure` would be very evil!)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first version is dynamically scoped: if I attempt to reference a variable
    that is not defined by the lambda’s arguments, I look for it in the environment
    that is *calling* the lambda. The second version is lexically scoped: I look for
    a missing variable in the environment that *created* the lambda, which happens
    to be where the lambda’s source code is, as well.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what does it mean to “delay” a reference to a variable? If it is lexically
    scoped, not much: the environment that the procedure is to use is set in stone
    from the moment it was created, and if the environment is immutable (that is,
    we disallow `set!` and friends), it doesn’t matter at all when we attempt to dereference
    a variable.'
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if the variable is dynamically scoped, the time when we call
    the function that references the variable is critical. Since Lisps are strictly
    evaluated, a plain `variable` expression will immediately cause a lookup in the
    current calling environment, but a “thunk” in the form of `(lambda () variable)`
    will delay looking up the variable until we force the `thunk` with `(thunk)`.
    `variable` is directly analogous to a value typed `r` in Haskell, while `(lambda
    () variable)` is analogous to a value typed `Reader r r`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back to Haskell, and to implicit parameters. The million dollar question is:
    can we distinguish between forcing and delaying an implicit parameter? If we attempt
    a verbatim translation of the original code, we get stuck very quickly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The syntax for implicit parameters doesn’t appear to have any built-in syntax
    for distinguishing `x` and `m`. Thus, one must wonder, what is the default behavior,
    and can the other way be achieved?
  prefs: []
  type: TYPE_NORMAL
- en: 'In what is a rarity for Haskell, the *types* in fact change the semantics of
    the expression. Consider this annotated version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The type of `x` is `Int`. Recall that the `(?x :: t)` constraint indicates
    that an expression uses that implicit variable. How can this be: aren’t we illegally
    using an implicit variable when we agreed not to? There is one way out of this
    dilemma: we force the value of `?x` and assign that to `x` for the rest of time:
    since we’ve already resolved `?x`, there is no need to require it wherever `x`
    may be used. Thus, *removing the implicit variables from the type constraint of
    an expression forces the implicit variables in that expression.*'
  prefs: []
  type: TYPE_NORMAL
- en: '`m`, on the other hand, performs no such specialization: it proclaims that
    you need `?x` in order to use the expression `m`. Thus, evaluation of the implicit
    variable is delayed. *Keeping an implicit variable in the type constraint delays
    that variable.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if one simply writes `let mystery = ?x`, what is the type of mystery? Here,
    the dreaded [monomorphism restriction](http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/monomorphism.html)
    kicks in. You may have seen the monomorphism restriction before: in most cases,
    it makes your functions less general than you would like them to be. However,
    this is quite obvious—your program fails to typecheck. Here, whether or not the
    monomorphism restriction is on will not cause your program to fail typechecking;
    it will merely change it’s behavior. My recommendation is to not guess, and explicitly
    specify your type signatures when using implicit parameters. This gives clear
    visual cues on whether or not the implicit parameter is being forced or delayed.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Aside.* For the morbidly curious, if the monomorphism restriction is enabled
    (as it is by default) and your expression is eligible (if it takes no arguments,
    it is definitely eligible, otherwise, [consult your nearest Haskell report](http://www.haskell.org/onlinereport/decls.html#sect4.5.5)),
    all implicit parameters will be specialized out of your type, so `let mystery
    = ?x` will force `?x` immediately. Even if you have carefully written the type
    for your implicit parameter, a monomorphic lambda or function can also cause your
    expression to become monomorphic. If the monomorphism restriction is disabled
    with `NoMonomorphismRestriction`, the inference algorithm will preserve your implicit
    parameters, delaying them until they are used in a specialized context without
    the implicit parameters. GHC also experimentally makes pattern bindings monomorphic,
    which is tweaked by `NoMonoPatBinds`.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The story’s not complete, however: I’ve omitted `m2` and `m3`!'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'But `m3` prints `3` not `2`! We’ve specified our full signature, as we were
    supposed to: what’s gone wrong?'
  prefs: []
  type: TYPE_NORMAL
- en: 'The trouble is, the *moment* we try to use `m2` to pass it out of the inner
    scope back out to the outer scope, we force the implicit parameter, and the `m3`
    that emerges is nothing more than an `m3 :: Int`. Even if we try to specify that
    `m3` is supposed to take an implicit parameter `?x`, the parameter gets ignored.
    You can liken it to the following chain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`g` is monomorphic: no amount of coaxing will make `?x` unbound again.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our brief trip in Scheme-land, however, suggests a possible way to prevent
    `m2` from being used prematurely: put it in a thunk.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: But we find that when we run `f2 ()`, the signature goes monomorphic, once again
    too early. While in Scheme, creating a thunk worked because dynamic binding was
    intimately related to *execution model*, in Haskell, implicit parameters are ruled
    by the types, and the types are not right.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dan Doel [discovered](http://hackage.haskell.org/trac/ghc/ticket/4226) that
    there is a way to make things work: move the `?x` constraint to the right hand
    side of the signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the style of higher ranks, this is very brittle (the slightest touch, such
    as an `id` function, can cause the higher-rank to go away). Simon Peyton Jones
    was surprised by this behavior, so don’t get too attached to it.
  prefs: []
  type: TYPE_NORMAL
- en: Here is another way to get “true” dynamic binding, as well as a monadic interface
    that, in my opinion, makes bind time much clearer. It is patterned after Oleg’s
    [monadic regions](http://okmij.org/ftp/Haskell/regions.html).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a hybrid approach: every time we add a new parameter in the form of
    a `ReaderT` monad, we generate a “label” which will allow us to refer back to
    that monad (this is done by using the type of the label to lift our way back to
    the original monad). However, instead of passing labels lexically, we stuff them
    in implicit parameters. There is then a custom `askl` function, which takes a
    label as an argument and returns the environment corresponding to that monad.
    The handle works even if you change the environment with `local`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Explaining this mechanism in more detail might be the topic of another post;
    it’s quite handy and very lightweight.
  prefs: []
  type: TYPE_NORMAL
- en: '*Conclusion.* If you plan on using implicit variables as nothing more than
    glorified static variables that happen to be changeable at runtime near the very
    top of your program, the monomorphism restriction is your friend. However, to
    be safe, force all your implicit parameters. You don’t need to worry about the
    difficulty of letting implicit variables escape through the output of a function.'
  prefs: []
  type: TYPE_NORMAL
- en: If you plan on using dynamic scoping for fancier things, you may be better off
    using [Oleg-style dynamic binding](http://okmij.org/ftp/Computation/dynamic-binding.html#DDBinding)
    and using implicit parameters as a convenient way to pass around labels.
  prefs: []
  type: TYPE_NORMAL
- en: '*Postscript.* Perhaps the fact that explaining the interaction of monomorphism
    and implicit parameters took so long may be an indication that advanced use of
    both may not be for the casual programmer.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
