["```\nallocateRegsAndSpill reading keep spills alloc (r:rs)\n = do   assig <- getAssigR\n        case lookupUFM assig r of\n                -- case (1a): already in a register\n                Just (InReg my_reg) ->\n                        allocateRegsAndSpill reading keep spills (my_reg:alloc) rs\n\n                -- case (1b): already in a register (and memory)\n                -- NB1\\. if we're writing this register, update its assignment to be\n                -- InReg, because the memory value is no longer valid.\n                -- NB2\\. This is why we must process written registers here, even if they\n                -- are also read by the same instruction.\n                Just (InBoth my_reg _)\n                 -> do  when (not reading) (setAssigR (addToUFM assig r (InReg my_reg)))\n                        allocateRegsAndSpill reading keep spills (my_reg:alloc) rs\n\n                -- Not already in a register, so we need to find a free one...\n                loc -> allocRegsAndSpill_spill reading keep spills alloc r rs loc assig\n\n```", "```\ndata Loc\n        -- | vreg is in a register\n        = InReg   !RealReg\n\n        -- | vreg is held in a stack slot\n        | InMem   {-# UNPACK #-}  !StackSlot\n\n        -- | vreg is held in both a register and a stack slot\n        | InBoth   !RealReg\n                   {-# UNPACK #-} !StackSlot\n        deriving (Eq, Show, Ord)\n\n```", "```\nlet new_loc\n        -- if the tmp was in a slot, then now its in a reg as well\n        | Just (InMem slot) <- loc\n        , reading\n        = InBoth my_reg slot\n\n        -- tmp has been loaded into a reg\n        | otherwise\n        = InReg my_reg\n\n```", "```\nlet new_loc\n        -- if the tmp was in a slot, then now its in a reg as well\n        | Just (InMem slot) <- loc\n        = if reading then InBoth my_reg slot else InReg my_reg\n\n        -- tmp has been loaded into a reg\n        | Nothing <- loc\n        = InReg my_reg\n\n        | otherwise = panic \"Impossible situation!\"\n\n```", "```\n-- Why are we performing a spill?\ndata SpillLoc = ReadMem StackSlot  -- reading from register only in memory\n              | WriteNew           -- writing to a new variable\n              | WriteMem           -- writing to register only in memory\n-- Note that ReadNew is not valid, since you don't want to be reading\n-- from an uninitialized register.  We also don't need the location of\n-- the register in memory, since that will be invalidated by the write.\n-- Technically, we could coalesce WriteNew and WriteMem into a single\n-- entry as well. -- EZY\n\nallocateRegsAndSpill reading keep spills alloc (r:rs)\n = do       assig <- getAssigR\n        let doSpill = allocRegsAndSpill_spill reading keep spills alloc r rs assig\n        case lookupUFM assig r of\n                -- case (1a): already in a register\n                Just (InReg my_reg) ->\n                        allocateRegsAndSpill reading keep spills (my_reg:alloc) rs\n\n                -- case (1b): already in a register (and memory)\n                -- NB1\\. if we're writing this register, update its assignment to be\n                -- InReg, because the memory value is no longer valid.\n                -- NB2\\. This is why we must process written registers here, even if they\n                -- are also read by the same instruction.\n                Just (InBoth my_reg _)\n                 -> do      when (not reading) (setAssigR (addToUFM assig r (InReg my_reg)))\n                        allocateRegsAndSpill reading keep spills (my_reg:alloc) rs\n\n                -- Not already in a register, so we need to find a free one...\n                Just (InMem slot) | reading   -> doSpill (ReadMem slot)\n                                  | otherwise -> doSpill WriteMem\n                Nothing | reading   -> pprPanic \"allocateRegsAndSpill: Cannot read from uninitialized register\" (ppr r)\n                        | otherwise -> doSpill WriteNew\n\n```", "```\n-- | Calculate a new location after a register has been loaded.\nnewLocation :: SpillLoc -> RealReg -> Loc\n-- if the tmp was read from a slot, then now its in a reg as well\nnewLocation (ReadMem slot) my_reg = InBoth my_reg slot\n-- writes will always result in only the register being available\nnewLocation _ my_reg = InReg my_reg\n\n```"]