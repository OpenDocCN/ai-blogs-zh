["```\ndatatype yn = Yes1 | No1\ndatatype ynm = Yes2 | No2 | Maybe2\n\n```", "```\ncon yn = variant [Yes = unit, No = unit]\ncon ynm = variant [Yes = unit, No = unit, Maybe = unit]\n\n```", "```\n$[A = int, B = bool]\n\n```", "```\nvariant [A = int, B = bool]\n\n```", "```\nmake [#A] 2\n\n```", "```\nval make : nm :: Name\n        -> t ::: Type\n        -> ts ::: {Type}\n        -> [[nm] ~ ts]\n        => t -> variant ([nm = t] ++ ts)\n\n```", "```\nmatch t { A = fn a => a + 2,\n          B = fn b => if b then 3 else 6 }\n\n```", "```\nval match : ts ::: {Type}                (* the type-level record *)\n         -> t ::: Type\n         -> variant ts                   (* the variant *)\n         -> $(map (fn t' => t' -> t) ts) (* the record *)\n         -> t\n\n```", "```\nval read : r ::: {Unit} -> t ::: Type -> folder r\n        -> $(mapU t r) -> variant (mapU {} r) -> t\nval write : r ::: {Unit} -> t ::: Type -> folder r\n        -> $(mapU t r) -> variant (mapU {} r) -> t -> $(mapU t r)\n\n```", "```\nread {A = 1, B = 2} (make [#A] ())\n== 1\n\nwrite {A = 1, B = 2} (make [#B] ()) 3\n== {A = 1, B = 3}\n\nsearch (fn v => match v {A = fn () => None, B = fn () => Some 2})\n== Some 2\n\nfind (fn v => match v {A = fn () => True, B = fn () => False})\n== Some (make [#A] ())\n\ntest [#A] (make [#A] 2)\n== Some 2\n\nweaken (make [#A] 2 : variant [A = int])\n== make [#A] 2 : variant [A = int, B = int]\n\neq (make [#A] ()) (make [#B] ())\n== False\n\nmp (fn v => match v {A = fn () => 2, B = fn () => True})\n== {A = 2, B = True}\n\nfold (fn v i => match v {A = fn () => i + 1, B = fn () => i + 2}) 0\n== 3\n\nmapR (fn v x => match v {A = fn i => i * 2, B = fn i => i * 3}) { A = 2 , B = 3 }\n== { A = 4, B = 9 }\n\n```", "```\nval destrR : K --> f :: (K -> Type) -> fr :: (K -> Type) -> t ::: Type\n          -> (p :: K -> f p -> fr p -> t)\n          -> r ::: {K} -> folder r -> variant (map f r) -> $(map fr r) -> t\n\n```", "```\nmatch [ts] [t] v fs =\n  destrR [ident] [fn p => p -> t] (fn [p ::_] f x => f x) v fs\n\n```", "```\ncon tactic a =\n  [Cut = logic * a * a,\n   LExact = int,\n   LConj = int * a,\n   LDisj = int * a * a,\n   LImp = int * a * a,\n   LIff = int * a,\n   LBot = int,\n   LTop = int * a,\n   LNot = int * a,\n   LForall = int * universe * a,\n   LExists = int * a,\n   LContract = int * a,\n   LWeaken = int * a,\n   RExact = int,\n   RConj = int * a * a,\n   RDisj = int * a,\n   RImp = int * a,\n   RIff = int * a * a,\n   RTop = int,\n   RBot = int * a,\n   RNot = int * a,\n   RForall = int * a,\n   RExists = int * universe * a,\n   RWeaken = int * a,\n   RContract = int * a]\n\n```", "```\nlet fun empty _ = True\n    fun single (_, a) = proofComplete a\n    fun singleQ (_, _, a) = proofComplete a\n    fun double (_, a, b) = andB (proofComplete a) (proofComplete b)\nin match t {Cut       = fn (_, a, b) => andB (proofComplete a) (proofComplete b),\n            LExact    = empty,\n            LBot      = empty,\n            RExact    = empty,\n            RTop      = empty,\n            LConj     = single,\n            LNot      = single,\n            LExists   = single,\n            LContract = single,\n            LWeaken   = single,\n            LTop      = single,\n            RDisj     = single,\n            RImp      = single,\n            LIff      = single,\n            RNot      = single,\n            RBot      = single,\n            RForall   = single,\n            RContract = single,\n            RWeaken   = single,\n            LForall   = singleQ,\n            RExists   = singleQ,\n            LDisj     = double,\n            LImp      = double,\n            RIff      = double,\n            RConj     = double\n            }\nend\n\n```", "```\nlet val empty   = declareCase (fn _ (_ : int) => True)\n    val single  = declareCase (fn _ (_ : int, a) => proofComplete a)\n    val singleQ = declareCase (fn _ (_ : int, _ : Universe.r, a) => proofComplete a)\n    val double  = declareCase (fn _ (_ : int, a, b) => andB (proofComplete a) (proofComplete b))\n    val cut     = declareCase (fn _ (_ : Logic.r, a, b) => andB (proofComplete a) (proofComplete b))\nin typeCase t end\n\n```", "```\nfun ctors : ts ::: {Type} -> fl : folder ts -> $(map (fn t => t -> variant ts) ts)\n\n```", "```\nfun ctors [ts] fl =\n  @fold [fn ts' => $(map (fn t => t -> variant ts) ts')]\n      (fn [nm ::_] [v ::_] [r ::_] [[nm] ~ r] n => n ++ {nm = make [nm]})\n      {} fl\n\n```", "```\ncon accum r = s :: {Type} -> [r ~ s] => $(map (fn t => t -> variant (r ++ s)) r)\nfun ctors [ts] fl =\n  @fold [accum]\n        (fn [nm::_] [v::_] [r::_] [[nm] ~ r]\n            (k : accum r)\n            [s::_] [[nm = v] ++ r ~ s] => k [[nm = v] ++ s] ++ {nm = make [nm]})\n        (fn [s::_] [[] ~ s] => {}) fl [[]] !\n\n```", "```\nr = [],                  nm = A, s = [B = bool, C = string]\nr = [A = int],           nm = B, s = [C = string]\nr = [A = int, B = bool], nm = C, s = []\n\n```"]