["```\nezyang@sabre:~$ ghc-8.2 --version\nThe Glorious Glasgow Haskell Compilation System, version 8.2.1\n\n```", "```\nunit main where\n  module Main where\n    main = putStrLn \"Hello world!\"\n\n```", "```\nunit regex where\n    module Regex where\n        -- | A type of regular expressions.\n        data Reg = Eps\n                 | Sym Char\n                 | Alt Reg Reg\n                 | Seq Reg Reg\n                 | Rep Reg\n\n        -- | Check if a regular expression 'Reg' matches a 'String'\n        accept :: Reg -> String -> Bool\n        accept Eps       u = null u\n        accept (Sym c)   u = u == [c]\n        accept (Alt p q) u = accept p u || accept q u\n        accept (Seq p q) u =\n            or [accept p u1 && accept q u2 | (u1, u2) <- splits u]\n        accept (Rep r) u =\n            or [and [accept r ui | ui <- ps] | ps <- parts u]\n\n        -- | Given a string, compute all splits of the string.\n        -- E.g., splits \"ab\" == [(\"\",\"ab\"), (\"a\",\"b\"), (\"ab\",\"\")]\n        splits :: String -> [(String, String)]\n        splits [] = [([], [])]\n        splits (c:cs) = ([], c:cs):[(c:s1,s2) | (s1,s2) <- splits cs]\n\n        -- | Given a string, compute all possible partitions of\n        -- the string (where all partitions are non-empty).\n        -- E.g., partitions \"ab\" == [[\"ab\"],[\"a\",\"b\"]]\n        parts :: String -> [[String]]\n        parts [] = [[]]\n        parts [c] = [[[c]]]\n        parts (c:cs) = concat [[(c:p):ps, [c]:p:ps] | p:ps <- parts cs]\n\nunit main where\n    dependency regex\n    module Main where\n        import Regex\n        nocs = Rep (Alt (Sym 'a') (Sym 'b'))\n        onec = Seq nocs (Sym 'c')\n        -- | The regular expression which tests for an even number of cs\n        evencs = Seq (Rep (Seq onec onec)) nocs\n        main = print (accept evencs \"acc\")\n\n```", "```\n    signature Str where\n      data Str\n      splits :: Str -> [(Str, Str)]\n      parts :: Str -> [[Str]]\n\n    ```", "```\n    regex.bkp:90:35: error:\n        • Couldn't match expected type ‘t0 a0’ with actual type ‘Str’\n        • In the first argument of ‘null’, namely ‘u’\n          In the expression: null u\n          In an equation for ‘accept’: accept Eps u = null u\n\n    regex.bkp:91:35: error:\n        • Couldn't match expected type ‘Str’ with actual type ‘[Char]’\n        • In the second argument of ‘(==)’, namely ‘[c]’\n          In the expression: u == [c]\n          In an equation for ‘accept’: accept (Sym c) u = u == [c]\n\n    ```", "```\nunit regex-indef where\n    signature Str where\n        data Str\n        instance Eq Str\n        null :: Str -> Bool\n        singleton :: Char -> Str\n        splits :: Str -> [(Str, Str)]\n        parts :: Str -> [[Str]]\n    module Regex where\n        import Prelude hiding (null)\n        import Str\n\n        data Reg = Eps\n                 | Sym Char\n                 | Alt Reg Reg\n                 | Seq Reg Reg\n                 | Rep Reg\n\n        accept :: Reg -> Str -> Bool\n        accept Eps       u = null u\n        accept (Sym c)   u = u == singleton c\n        accept (Alt p q) u = accept p u || accept q u\n        accept (Seq p q) u =\n            or [accept p u1 && accept q u2 | (u1, u2) <- splits u]\n        accept (Rep r) u =\n            or [and [accept r ui | ui <- ps] | ps <- parts u]\n\n```", "```\nunit str-string where\n    module Str where\n        import Prelude hiding (null)\n        import qualified Prelude as P\n\n        type Str = String\n\n        null :: Str -> Bool\n        null = P.null\n\n        singleton :: Char -> Str\n        singleton c = [c]\n\n        splits :: Str -> [(Str, Str)]\n        splits [] = [([], [])]\n        splits (c:cs) = ([], c:cs):[(c:s1,s2) | (s1,s2) <- splits cs]\n\n        parts :: Str -> [[Str]]\n        parts [] = [[]]\n        parts [c] = [[[c]]]\n        parts (c:cs) = concat [[(c:p):ps, [c]:p:ps] | p:ps <- parts cs]\n\n```", "```\n-- dependency regex -- old\ndependency regex-indef[Str=str-string:Str]\n\n```", "```\nunit str-bytestring where\n    module Str(module Data.ByteString.Char8, module Str) where\n        import Prelude hiding (length, null, splitAt)\n        import Data.ByteString.Char8\n        import Data.ByteString\n\n        type Str = ByteString\n\n        splits :: Str -> [(Str, Str)]\n        splits s = fmap (\\n -> splitAt n s) [0..length s]\n\n        parts :: Str -> [[Str]]\n        parts s | null s    = [[]]\n                | otherwise = do\n                    n <- [1..length s]\n                    let (l, r) = splitAt n s\n                    fmap (l:) (parts r)\n\n```", "```\n-- dependency regex -- oldest\n-- dependency regex-indef[Str=str-string:Str] -- old\ndependency regex-indef[Str=str-bytestring:Str]\n\n```", "```\ndependency regex-indef[Str=str-string:Str]     (Regex as Regex.String)\ndependency regex-indef[Str=str-bytestring:Str] (Regex as Regex.ByteString)\n\n```", "```\n{-# LANGUAGE OverloadedStrings #-}\n\nunit str-bytestring where\n    module Str(module Data.ByteString.Char8, module Str) where\n        import Prelude hiding (length, null, splitAt)\n        import Data.ByteString.Char8\n        import Data.ByteString\n\n        type Str = ByteString\n\n        splits :: Str -> [(Str, Str)]\n        splits s = fmap (\\n -> splitAt n s) [0..length s]\n\n        parts :: Str -> [[Str]]\n        parts s | null s    = [[]]\n                | otherwise = do\n                    n <- [1..length s]\n                    let (l, r) = splitAt n s\n                    fmap (l:) (parts r)\n\nunit str-string where\n    module Str where\n        import Prelude hiding (null)\n        import qualified Prelude as P\n\n        type Str = String\n\n        null :: Str -> Bool\n        null = P.null\n\n        singleton :: Char -> Str\n        singleton c = [c]\n\n        splits :: Str -> [(Str, Str)]\n        splits [] = [([], [])]\n        splits (c:cs) = ([], c:cs):[(c:s1,s2) | (s1,s2) <- splits cs]\n\n        parts :: Str -> [[Str]]\n        parts [] = [[]]\n        parts [c] = [[[c]]]\n        parts (c:cs) = concat [[(c:p):ps, [c]:p:ps] | p:ps <- parts cs]\n\nunit regex-types where\n    module Regex.Types where\n        data Reg = Eps\n                 | Sym Char\n                 | Alt Reg Reg\n                 | Seq Reg Reg\n                 | Rep Reg\n\nunit regex-indef where\n    dependency regex-types\n    signature Str where\n        data Str\n        instance Eq Str\n        null :: Str -> Bool\n        singleton :: Char -> Str\n        splits :: Str -> [(Str, Str)]\n        parts :: Str -> [[Str]]\n    module Regex where\n        import Prelude hiding (null)\n        import Str\n        import Regex.Types\n\n        accept :: Reg -> Str -> Bool\n        accept Eps       u = null u\n        accept (Sym c)   u = u == singleton c\n        accept (Alt p q) u = accept p u || accept q u\n        accept (Seq p q) u =\n            or [accept p u1 && accept q u2 | (u1, u2) <- splits u]\n        accept (Rep r) u =\n            or [and [accept r ui | ui <- ps] | ps <- parts u]\n\nunit main where\n    dependency regex-types\n    dependency regex-indef[Str=str-string:Str]     (Regex as Regex.String)\n    dependency regex-indef[Str=str-bytestring:Str] (Regex as Regex.ByteString)\n    module Main where\n        import Regex.Types\n        import qualified Regex.String\n        import qualified Regex.ByteString\n        nocs = Rep (Alt (Sym 'a') (Sym 'b'))\n        onec = Seq nocs (Sym 'c')\n        evencs = Seq (Rep (Seq onec onec)) nocs\n        main = print (Regex.String.accept evencs \"acc\") >>\n               print (Regex.ByteString.accept evencs \"acc\")\n\n```"]