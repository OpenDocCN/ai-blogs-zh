["```\ndecls : decls ';' decl\n      | decls ';'\n      | decl\n      | {- empty -}\n\n```", "```\n{- empty -}                             (rule 4)\n{- empty -} ';' decl                    (rule 1)\n{- empty -} ';' decl ';'                (rule 2)\n{- empty -} ';' decl ';' ';' decl       (rule 1)\n{- empty -} ';' decl ';' ';' decl ';'   (rule 2)\n\n```", "```\nimportdecls :: { ([AddAnn],[LImportDecl RdrName]) }\n        : importdecls ';' importdecl\n                                {% if null (snd $1)\n                                     then return (mj AnnSemi $2:fst $1,$3 : snd $1)\n                                     else do\n                                      { addAnnotation (gl $ head $ snd $1)\n                                                      AnnSemi (gl $2)\n                                      ; return (fst $1,$3 : snd $1) } }\n        | importdecls ';'       {% if null (snd $1)\n                                     then return ((mj AnnSemi $2:fst $1),snd $1)\n                                     else do\n                                       { addAnnotation (gl $ head $ snd $1)\n                                                       AnnSemi (gl $2)\n                                       ; return $1} }\n        | importdecl             { ([],[$1]) }\n        | {- empty -}            { ([],[]) }\n\n```", "```\n    semis : semis ';'\n          | {- empty -}\n\n    ```", "```\n    semis1 : semis1 ';'\n           | ';'\n\n    ```", "```\n-- Possibly empty decls with mandatory trailing semicolons\ndecls_semi : decls_semi decl semis1\n           | {- empty -}\n\n-- Non-empty decls with no trailing semicolons\ndecls : decls_semi decl\n\n-- Possibly empty decls with optional trailing semicolons\ntop1 : decls_semi\n     | decls\n\n-- Possibly empty decls with optional leading/trailing semicolons\ntop : semi top1\n\n```", "```\ntop : importdecls_semi topdecls_semi\n    | importdecls_semi topdecls\n    | importdecls\n\n```", "```\n{\nmodule Main where\n\nimport Data.Char\n}\n\n%name parse\n%expect 0\n%tokentype { Token }\n%error { parseError }\n\n%token\n      import          { TokenImport }\n      decl            { TokenDecl }\n      ';'             { TokenSemi }\n\n%%\n\ntop     : semis top1                        { $2 }\ntop1    : importdecls_semi topdecls_semi    { (reverse $1, reverse $2) }\n        | importdecls_semi topdecls         { (reverse $1, reverse $2) }\n        | importdecls                       { (reverse $1, []) }\n\nid_semi : importdecl semis1                 { $1 }\nimportdecls\n        : importdecls_semi importdecl       { $2:$1 }\nimportdecls_semi\n        : importdecls_semi id_semi          { $2:$1 }\n        | {- empty -}                       { [] }\n\ntopdecls\n        : topdecls_semi topdecl             { $2:$1 }\ntopdecls_semi\n        : topdecls_semi topdecl semis1      { $2:$1 }\n        | {- empty -}                       { [] }\n\nsemis   : semis ';'                         { () }\n        | {- empty -}                       { () }\n\nsemis1  : semis1 ';'                        { () }\n        | ';'                               { () }\n\nimportdecl\n        : import                            { \"import\" }\ntopdecl : decl                              { \"decl\" }\n\n{\nparseError :: [Token] -> a\nparseError p = error (\"Parse error: \" ++ show p)\n\ndata Token\n      = TokenImport\n      | TokenDecl\n      | TokenSemi\n deriving Show\n\nlexer :: String -> [Token]\nlexer [] = []\nlexer (c:cs)\n      | isSpace c = lexer cs\n      | isAlpha c = lexVar (c:cs)\nlexer (';':cs) = TokenSemi : lexer cs\n\nlexVar cs =\n   case span isAlpha cs of\n      (\"import\",rest) -> TokenImport : lexer rest\n      (\"decl\",rest) -> TokenDecl : lexer rest\n\nmain = print . parse . lexer $ \"import;;import;;decl\"\n}\n\n```"]