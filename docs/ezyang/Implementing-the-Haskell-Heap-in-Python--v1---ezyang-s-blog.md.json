["```\nheap = {} # global\n\n# ---------------------------------------------------------------------#\n\nclass Present(object): # Thunk\n    def __init__(self, ghost):\n        self.ghost    = ghost # Ghost haunting the present\n        self.opened   = False # Evaluated?\n        self.contents = None\n    def open(self):\n        if not self.opened:\n            # Hey ghost! Give me your present!\n            self.contents = self.ghost.disturb()\n            self.opened   = True\n            self.ghost    = None\n        return self.contents\n\nclass Ghost(object): # Code and closure\n    def __init__(self, *args):\n        self.tags = args # List of names of presents (closure)\n    def disturb(self):\n        raise NotImplemented\n\nclass Inside(object):\n    pass\nclass GiftCard(Inside): # Constructor\n    def __init__(self, name, *args):\n        self.name  = name  # Name of gift card\n        self.items = args # List of presents on heap you can redeem!\n    def __str__(self):\n        return \" \".join([self.name] + map(str, self.items))\nclass Box(Inside): # Boxed, primitive data type\n    def __init__(self, prim):\n        self.prim = prim # Like an integer\n    def __str__(self):\n        return str(self.prim)\n\n# ---------------------------------------------------------------------#\n\nclass IndirectionGhost(Ghost):\n    def disturb(self):\n        # Your present is in another castle!\n        return heap[self.tags[0]].open()\nclass AddingGhost(Ghost):\n    def disturb(self):\n        # Gotta make your gift, be back in a jiffy!\n        item_1 = heap[self.tags[0]].open()\n        item_2 = heap[self.tags[1]].open()\n        result = item_1.prim + item_2.prim\n        return Box(result)\nclass UnsafePerformIOGhost(Ghost):\n    def disturb(self):\n        print \"Fire ze missiles!\"\n        return heap[self.tags[0]].open()\nclass PSeqGhost(Ghost):\n    def disturb(self):\n        heap[self.tags[0]].open() # Result ignored!\n        return heap[self.tags[1]].open()\nclass TraceGhost(Ghost):\n    def disturb(self):\n        print \"Tracing %s\" % self.tags[0]\n        return heap[self.tags[0]].open()\nclass ExplodingGhost(Ghost):\n    def disturb(self):\n        print \"Boom!\"\n        raise Exception\n\n# ---------------------------------------------------------------------#\n\ndef evaluate(tag):\n    print \"> evaluate %s\" % tag\n    heap[tag].open()\n\ndef makeOpenPresent(x):\n    present = Present(None)\n    present.opened = True\n    present.contents = x\n    return present\n\n# Let's put some presents in the heap (since we can't make presents\n# of our own yet.)\n\nheap['bottom']  = Present(ExplodingGhost())\nheap['io']      = Present(UnsafePerformIOGhost('just_1'))\nheap['just_1']  = makeOpenPresent(GiftCard('Just', 'bottom'))\nheap['1']       = makeOpenPresent(Box(1))\nheap['2']       = makeOpenPresent(Box(2))\nheap['3']       = makeOpenPresent(Box(3))\nheap['traced_1']= Present(TraceGhost('1'))\nheap['traced_2']= Present(TraceGhost('2'))\nheap['traced_x']= Present(TraceGhost('x'))\nheap['x']       = Present(AddingGhost('traced_1', '3'))\nheap['y']       = Present(PSeqGhost('traced_2', 'x'))\nheap['z']       = Present(IndirectionGhost('traced_x'))\n\nprint \"\"\"$ cat src.hs\nimport Debug.Trace\nimport System.IO.Unsafe\nimport Control.Parallel\nimport Control.Exception\n\nbottom = error \"Boom!\"\nio = unsafePerformIO (putStrLn \"Fire ze missiles\" >> return (Just 1))\ntraced_1 = trace \"Tracing 1\" 1\ntraced_2 = trace \"Tracing 2\" 2\ntraced_x = trace \"Tracing x\" x\nx = traced_1 + 3\ny = pseq traced_2 x\nz = traced_x\n\nmain = do\n    putStrLn \"> evaluate 1\"\n    evaluate 1\n    putStrLn \"> evaluate z\"\n    evaluate z\n    putStrLn \"> evaluate z\"\n    evaluate z\n    putStrLn \"> evaluate y\"\n    evaluate y\n    putStrLn \"> evaluate io\"\n    evaluate io\n    putStrLn \"> evaluate io\"\n    evaluate io\n    putStrLn \"> evaluate bottom\"\n    evaluate bottom\n$ runghc src.hs\"\"\"\n\n# Evaluating an already opened present doesn't do anything\nevaluate('1')\n\n# Evaluating an indirection ghost forces us to evaluate another present\nevaluate('z')\n\n# Once a present is opened, it stays opened\nevaluate('z')\n\n# Evaluating a pseq ghost may mean extra presents get opened\nevaluate('y')\n\n# unsafePerformIO can do anything, but maybe only once..\nevaluate('io')\nevaluate('io')\n\n# Exploding presents may live in the heap, but they're only dangerous\n# if you evaluate them...\nevaluate('bottom')\n\n```", "```\npseq =\n  \\ (@ a) (@ b) (x :: a) (y :: b) ->\n    case x of _ { __DEFAULT -> y }\n\n```", "```\nadd =\n  \\ (bx :: GHC.Types.Int) (by :: GHC.Types.Int) ->\n    case bx of _ { GHC.Types.I# x ->\n      case by of _ { GHC.Types.I# y ->\n        GHC.Types.I# (GHC.Prim.+# x y)\n      }\n    }\n\n```"]