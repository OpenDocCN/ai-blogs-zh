- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-07-01 18:17:52'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: 'Unraveling the mystery of the IO monad : ezyang’s blog'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[http://blog.ezyang.com/2011/05/unraveling-the-mystery-of-the-io-monad/](http://blog.ezyang.com/2011/05/unraveling-the-mystery-of-the-io-monad/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'When we teach beginners about Haskell, one of the things we handwave away is
    how the IO monad works. Yes, it’s a monad, and yes, it does IO, but it’s not something
    you can implement in Haskell itself, giving it a somewhat magical quality. In
    today’s post, I’d like to unravel the mystery of the IO monad by describing how
    GHC implements the IO monad internally in terms of primitive operations and the
    real world token. After reading this post, you should be able to understand the
    [resolution of this ticket](http://hackage.haskell.org/trac/ghc/ticket/5129) as
    well as the Core output of this Hello World! program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Nota bene: **This is not a monad tutorial**. This post assumes the reader knows
    what monads are! However, the first section reviews a critical concept of strictness
    as applied to monads, because it is critical to the correct functioning of the
    IO monad.'
  prefs: []
  type: TYPE_NORMAL
- en: The lazy and strict State monad
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As a prelude to the IO monad, we will briefly review the State monad, which
    forms the operational basis for the IO monad (the IO monad is implemented as if
    it were a strict State monad with a *special* form of state, though there are
    some important differences—that’s the magic of it.) If you feel comfortable with
    the difference between the lazy and strict state monad, you can skip this section.
    Otherwise, read on. The data type constructor of the State monad is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'A running a computation in the state monad involves giving it some incoming
    state, and retrieving from it the resulting state and the actual value of the
    computation. The monadic structure involves *threading* the state through the
    various computations. For example, this snippet of code in the state monad:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'could be rewritten (with the newtype constructor removed) as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, a rather interesting experiment I would like to pose for the reader is
    this: suppose that `doSomething` and `doSomethingElse` were traced: that is, when
    evaluated, they outputted a trace message. That is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Is there ever a situation in which the trace for `doSomethingElse` would fire
    before `doSomething`, in the case that we forced the result of the elements of
    this do block? In a strict language, the answer would obviously be no; you have
    to do each step of the stateful computation in order. But Haskell is lazy, and
    in another situation it’s conceivable that the result of `doSomethingElse` might
    be requested before `doSomething` is. Indeed, here is such an example of some
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: What has happened is that we are lazy in the state value, so when we demanded
    the value of `s''`, we forced `doSomethingElse` and were presented with an indirection
    to `s'`, which then caused us to force `doSomething`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we actually did want `doSomething` to always execute before `doSomethingElse`.
    In this case, we can fix things up by making our state strict:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This subtle transformation from let (which is lazy) to case (which is strict)
    lets us now preserve ordering. In fact, it will turn out, we won’t be given a
    choice in the matter: due to how primitives work out we have to do things this
    way. Keep your eye on the case: it will show up again when we start looking at
    Core.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Bonus.* Interestingly enough, if you use irrefutable patterns, the case-code
    is equivalent to the original let-code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Primitives
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The next part of our story are the primitive types and functions provided by
    GHC. These are the mechanism by which GHC exports types and functionality that
    would not be normally implementable in Haskell: for example, unboxed types, adding
    together two 32-bit integers, or doing an IO action (mostly, writing bits to memory
    locations). They’re very GHC specific, and normal Haskell users never see them.
    In fact, they’re so special you need to enable a language extension to use them
    (the `MagicHash`)! The IO type is constructed with these primitives in `GHC.Types`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In order to understand the `IO` type, we will need to learn about a few of these
    primitives. But it should be very clear that this looks a lot like the state monad...
  prefs: []
  type: TYPE_NORMAL
- en: 'The first primitive is the *unboxed tuple*, seen in code as `(# x, y #)`. Unboxed
    tuples are syntax for a “multiple return” calling convention; they’re not actually
    real tuples and can’t be put in variables as such. We’re going to use unboxed
    tuples in place of the tuples we saw in `runState`, because it would be pretty
    terrible if we had to do heap allocation every time we performed an IO action.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next primitive is `State# RealWorld`, which will correspond to the `s`
    parameter of our state monad. Actually, it’s two primitives, the type constructor
    `State#`, and the magic type `RealWorld` (which doesn’t have a `#` suffix, fascinatingly
    enough.) The reason why this is divided into a type constructor and a type parameter
    is because the `ST` monad also reuses this framework—but that’s a matter for another
    blog post. You can treat `State# RealWorld` as a type that represents a very magical
    value: the value of the entire real world. When you ran a state monad, you could
    initialize the state with any value you cooked up, but only the `main` function
    receives a real world, and it then gets threaded along any IO code you may end
    up having executing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One question you may ask is, “What about `unsafePerformIO`?” In particular,
    since it may show up in any pure computation, where the real world may not necessarily
    available, how can we fake up a copy of the real world to do the equivalent of
    a nested `runState`? In these cases, we have one final primitive, `realWorld#
    :: State# RealWorld`, which allows you to grab a reference to the real world wherever
    you may be. But since this is not hooked up to `main`, you get absolutely *no*
    ordering guarantees.'
  prefs: []
  type: TYPE_NORMAL
- en: Hello World
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s return to the Hello World program that I promised to explain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When we compile this, we get some core that looks like this (certain bits,
    most notably the casts (which, while a fascinating demonstration of how newtypes
    work, have no runtime effect), pruned for your viewing pleasure):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The important bit is `Main.main1`. Reformatted and renamed, it looks just like
    our desugared state monad:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The monads are all gone, and `hPutStr1 stdout main3 s`, while ostensibly always
    returning a value of type `(# State# RealWorld, () #)`, has side-effects. The
    repeated case-expressions, however, ensure our optimizer doesn’t reorder the IO
    instructions (since that would have a very observable effect!)'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the curious, here are some other notable bits about the core output:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `:main` function (with a colon in front) doesn’t actually go straight to
    our code: it invokes a wrapper function `GHC.TopHandler.runMainIO` which does
    some initialization work like installing the top-level interrupt handler.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unpackCString#` has the type `Addr# -> [Char]`, so what it does it transforms
    a null-terminated C string into a traditional Haskell string. This is because
    we store strings as null-terminated C strings whenever possible. If a null byte
    or other nasty binary is embedded, we would use `unpackCStringUtf8#` instead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`putStr` and `putStrLn` are nowhere in sight. This is because I compiled with
    `-O`, so these function calls got inlined.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The importance of being ordered
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To emphasize how important ordering is, consider what happens when you mix
    up `seq`, which is traditionally used with pure code and doesn’t give any order
    constraints, and IO, for which ordering is very important. That is, consider [Bug
    5129](http://hackage.haskell.org/trac/ghc/ticket/5129). Simon Peyton Jones gives
    a great explanation, so I’m just going to highlight how seductive (and wrong)
    code that isn’t ordered properly is. The code in question is ``x `seq` return
    ()``. What does this compile to? The following core:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the `seq` compiles into a `case` statement (since case statements
    in Core are strict), and also notice that there is no involvement with the `s`
    parameter in this statement. Thus, if this snippet is included in a larger fragment,
    these statements may get optimized around. And in fact, this is exactly what happens
    in some cases, as Simon describes. Moral of the story? Don’t write ``x `seq` return
    ()`` (indeed, I think there are some instances of this idiom in some of the base
    libraries that need to get fixed.) The new world order is a new primop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Much better!
  prefs: []
  type: TYPE_NORMAL
- en: This also demonstrates why `seq x y` gives absolutely no guarantees about whether
    or not `x` or `y` will be evaluated first. The optimizer may notice that `y` always
    gives an exception, and since imprecise exceptions don’t care which exception
    is thrown, it may just throw out any reference to `x`. Egads!
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most of the code that defines IO lives in the `GHC` supermodule in `base`, though
    the actual IO type is in `ghc-prim`. `GHC.Base` and `GHC.IO` make for particularly
    good reading.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Primops are described on the [GHC Trac](http://hackage.haskell.org/trac/ghc/wiki/Commentary/PrimOps).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The ST monad is also implemented in essentially the exact same way: the unsafe
    coercion functions just do some type shuffling, and don’t actually change anything.
    You can read more about it in `GHC.ST`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
