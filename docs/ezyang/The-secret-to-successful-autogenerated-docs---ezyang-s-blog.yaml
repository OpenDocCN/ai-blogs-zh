- en: <!--yml
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: 未分类'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 类别：未分类
- en: 'date: 2024-07-01 18:18:16'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 日期：2024-07-01 18:18:16
- en: -->
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: 'The secret to successful autogenerated docs : ezyang’s blog'
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 成功的自动生成文档秘诀：ezyang的博客
- en: 来源：[http://blog.ezyang.com/2010/06/secret-of-autogenerated-docs/](http://blog.ezyang.com/2010/06/secret-of-autogenerated-docs/)
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来源：[http://blog.ezyang.com/2010/06/secret-of-autogenerated-docs/](http://blog.ezyang.com/2010/06/secret-of-autogenerated-docs/)
- en: I've had a rather successful tenure with autogenerated documentation, both as
    a writer and a reader. So when [Jacob Kaplan Moss's articles on writing “great
    documentation”](http://jacobian.org/writing/great-documentation/what-to-write/)
    resurfaced on Reddit and had some harsh words about auto-generated documentation,
    I sat back a moment and thought about why autogenerated documentation leave developers
    with a bad taste in their mouths.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我在自动生成文档上有了相当成功的任期，既是作者又是读者。因此，当[雅各布·卡普兰·莫斯关于撰写“优秀文档”](http://jacobian.org/writing/great-documentation/what-to-write/)的文章在Reddit上重新浮出水面，并对自动生成的文档提出严厉批评时，我坐下来思考自动生成的文档为何让开发人员留下不快的印象。
- en: 'I interpreted Moss''s specific objections (besides asserting that they were
    “worthless” as the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我解释了莫斯的具体反对意见（除了断言它们“毫无价值”外）如下：
- en: They usually didn't contain the information you were looking for (*“At best
    it’s a slightly improved version of simply browsing through the source”*),
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们通常不包含你正在寻找的信息（*“At best it’s a slightly improved version of simply browsing
    through the source”*），
- en: They were verbose (*“good for is filling printed pages when contracts dictate
    delivery of a certain number of pages of documentation”*),
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们冗长（*“good for is filling printed pages when contracts dictate delivery of
    a certain number of pages of documentation”*），
- en: The writers skipped the “writing” part (*“There’s no substitute for documentation
    written...”*),
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作者们跳过了“写作”部分（*“There’s no substitute for documentation written...”*），
- en: The writers skipped the “organizing” part (*“...organized...”*),
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作者们跳过了“组织”部分（*“...organized...”*），
- en: The writers skipped the “editing” part (*“...and edited by hand.”*),
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作者们跳过了“编辑”部分（*“...and edited by hand.”*），
- en: It gave the illusion of having documentation (*“...it lets maintainers fool
    themselves into thinking they have documentation”*).
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它给了有文档的错觉（*“...it lets maintainers fool themselves into thinking they have documentation”*）。
- en: 'Thus, the *secret* to successful autogenerated docs is:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，成功自动生成文档的*秘密*是：
- en: Remember your audience.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 记住你的受众。
- en: No doubt, gentle reader, you are lifting your eyebrow at me, thinking to yourself,
    “Of course you should remember your audience; that's what they always teach you
    in any writing class. You haven't told us anything useful!” So, let me elaborate.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，亲爱的读者，你正在挑眉看着我，心里想着，“当然你应该记住你的受众；这是他们在任何写作课程中总是教你的。你没有告诉我们任何有用的东西！”所以，让我详细说明一下。
- en: '*Why do developers forget to “remember their audience”?* A defining characteristic
    of autogenerated documentation is that the medium it is derived from is source
    code: lines of programming language and docblocks interleaved together. This has
    certain benefits: for one, keeping the comments close to the code they describe
    helps ward off documentation rot as code changes, additionally, source divers
    have easy access to documentation pertinent to a source file they are reading.
    But documentation is *frequently* oriented towards people who are not interested
    in reading the codebase, and thus the act of writing code and documentation at
    the same time puts the writer into the wrong mindset. Compare this with sitting
    down to a tutorial, the text flowing into an empty document unprejudiced by such
    petty concerns as code.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么开发人员会忘记“记住他们的受众”？* 自动生成的文档的一个定义特征是其来源于源代码：编程语言的代码行和文档块交织在一起。这有一定的好处：首先，将注释保持在描述的代码附近有助于防止随着代码变化而出现文档腐败，此外，源代码开发人员可以轻松访问与他们正在阅读的源文件相关的文档。但文档**经常**是面向不愿意阅读代码库的人的，因此同时编写代码和文档会使编写者陷入错误的思维模式。将此与坐下来看教程相比，文本流入一个空白文档，不受代码等琐事的影响。'
- en: This is a shame, because in the case of end-user developer documentation (really
    the only appropriate time for autodocs), the person who originally wrote the code
    is most likely to have the relevant knowledge to share about the interface being
    documented.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这很遗憾，因为在最终用户开发人员文档的情况下（真正适合自动文档的唯一时机），最初编写代码的人最有可能拥有关于正在文档化的接口的相关知识。
- en: '*What does it mean to “remember my audience”?* Concisely, it''s putting yourself
    into your end-user’s shoes and asking yourself, “If I wanted to find out information
    about this API, what would I be looking for?” This can be hard (and unfortunately,
    there are no secrets here), but the first step is to be thinking about it at all.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*什么是“记住我的观众”的意思？* 简而言之，这意味着把自己放在最终用户的鞋子里，并问自己，“如果我想要找到关于这个API的信息，我会寻找什么？” 这可能很困难（不幸的是，这里没有秘密），但首先要考虑这个问题。'
- en: '*How can I remember to consider the audience when writing docblocks?* While
    it would be nice if I could just snap my fingers and say, “I''m going to write
    docblocks with my audience in mind,” I know that I''m going to forget and write
    a snippy docblock because I was in a rush one day or omit the docblock entirely
    and forget about it. Writing documentation immediately after the code is written
    can be frustrating if five minutes later you decide that function did the wrong
    thing and needs to be axed.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*在撰写文档块时如何记住观众？* 虽然如果我能一挥手就说，“我要以我的观众为中心撰写文档块”那就太好了，但我知道我会忘记，因为有一天我匆忙之下写了一个尖刻的文档块或者完全忘记了写文档块。如果在写代码后立即写文档，五分钟后发现那个函数做错了事情并需要剔除，这会很令人沮丧。'
- en: 'Thus, I''ve set up these two rules for myself:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我为自己设立了这两条规则：
- en: It's OK not to write documentation immediately after writing code (better not
    yet than poorly).
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写代码后立即撰写文档不是必须的（还不如不写）。
- en: Like many people working in high-level languages, I like using code to prototype
    API designs. I'll write something, try to use it, change it to fit my use-case,
    write some more, and eventually I'll have both working code and a working design.
    If I don't write documentation while I'm prototyping, that's fine, but when that's
    all over I need to write the documentation (hopefully before the code slips out
    of my active mindspace.) The act of writing the documentation at the end helps
    finalize the API, and can suggest finishing touches. I also use my toolchain to
    tell me when I've left code undocumented (with Sphinx, this is using the `coverage`
    plugin).
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 像许多使用高级语言的人一样，我喜欢用代码来原型化API设计。我会写一些东西，试着使用它，根据我的用例进行修改，再写一些，最终我既有了可工作的代码又有了可行的设计。如果我在原型设计时没有写文档，那也没关系，但当这一切结束时，我需要写文档（希望在代码还在我活跃的思维空间中）。在最后写文档的行为有助于最终确定API，并可以提出最后的触及点。我还使用我的工具链告诉我何时留下了未记录的代码（使用Sphinx时，这是使用`coverage`插件）。
- en: When writing documentation, constantly look at the output the end-user will
    see.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在撰写文档时，不断查看最终用户将看到的输出。
- en: 'You probably have a write/preview authoring cycle when you edit any sort of
    text that contains formatting. This cycle should carry over to docblocks: you
    edit your docblock, run your documentation build script, and inspect the results
    in your browser. It helps if the output you''re producing is beautiful! It also
    means that your documentation toolchain should be smart about what it needs to
    recompile when you make changes. The act of inspecting what a live user will see
    helps put you in the right mindset, and also force you to say, “Yeah, these docs
    are not actually acceptable.”'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你编辑任何包含格式的文本时，可能会有一个写作/预览的循环。这个循环应该延续到文档块中：你编辑你的文档块，运行你的文档构建脚本，然后在浏览器中查看结果。如果输出美观的话会很有帮助！这也意味着你的文档工具链应该智能地处理你做出的更改并重新编译所需的内容。检查最终用户会看到的内容有助于让你保持正确的心态，并且迫使你承认，“是的，这些文档实际上并不可接受。”
- en: '*My autodocumentor produces verbose and unorganized output!* I''ve generally
    found autogenerated documentation from Python or Haskell to be much more pleasant
    to read than that from Java or C++. The key difference between these languages
    is that Python and Haskell organize their modules into files; thus, programmers
    in those language find it easier to remember the module docblock!'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*我的自动文档生成器产生的输出冗长且杂乱无章！* 我一般发现Python或Haskell生成的自动化文档比Java或C++生成的文档更易阅读。这些语言的主要区别在于Python和Haskell将它们的模块组织到文件中；因此，使用这些语言的程序员更容易记住模块文档块！'
- en: The module docblock is one of great import. If your code is well-written and
    well-named, a competent source-diver can usually figure out what a particular
    function does in only a few times longer than it would take for them to read your
    docblock. The module is the first organizational unit above class and function,
    *precisely* where documentation starts becoming the most useful. It is the first
    form of “high-level documentation” that developers pine for.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 模块文档块是非常重要的一部分。如果你的代码写得好、命名得好，一个能力强的源码分析者通常可以在比读取你的文档块多几倍的时间内弄清楚某个特定函数的作用。模块是类和函数之上的第一个组织单位，*恰好*是文档开始变得最有用的地方。它是开发者渴望的“高级别文档”的第一形式。
- en: So, in Python and Haskell, you write all of the functionality involved in a
    module in a file, and you can stick a docblock up top that says what the entire
    file does. Easy! But in Java and C++, each file is a class (frequently a small
    one), so you don't get a chance to do that. Java and recent C++ have namespaces,
    which can play a similar role, but where are you supposed to put the docblock
    for what in Java is effectively a directory?
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在Python和Haskell中，你可以把一个模块中涉及的所有功能写在一个文件中，并且可以在顶部放一个文档块，说明整个文件的作用。很简单！但是在Java和C++中，每个文件都是一个类（通常是一个小类），所以你没有机会这样做。Java和最近的C++有命名空间，可以发挥类似的作用，但在Java中，对于实际上是目录的东西，你应该把文档块放在哪里呢？
- en: There is also substantial verbosity pollution that comes from an autodocumenting
    tool attempting to generate documentation for classes and functions that were
    intended to not be used by the end-user. Haddock (Haskell autodocumentor) strongly
    enforces this by not generating documentation for any function that the module
    doesn't export. Sphinx (Python autodocumentor) will ignore by default functions
    prefixed with an underscore. People documenting Java, which tends to need a lot
    of classes, should think carefully about which classes they actually want people
    to use.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 还有大量冗长的污染来自自动文档工具尝试生成文档，用于那些本来不打算供最终用户使用的类和函数。Haddock（Haskell自动文档工具）通过不为模块未导出的任何函数生成文档来强烈执行此规定。Sphinx（Python自动文档工具）默认情况下会忽略以下划线开头的函数。那些需要大量类的Java文档的人应该仔细考虑哪些类实际上他们希望人们使用。
- en: '*Final thoughts.* The word “autogenerated documentation” is a misnomer: there
    is no *automatic* generation of documentation. Rather, the autodocumentor should
    be treated as a valuable documentation building tool that lets you get the benefits
    of cohesive code and comments, as well as formatting, interlinking and more.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*最后的想法。* “自动生成的文档”这个词是一个误称：没有*自动*生成文档。相反，自动文档工具应该被视为一种有价值的文档构建工具，让你获得代码和注释的内聚性、格式化、相互链接等好处。'
