["```\n> {-# OPTIONS -fno-warn-missing-methods #-}\n\n```", "```\n> module Omega where\n>\n> import Data.Lub (HasLub(lub), flatLub)\n> import Data.Glb (HasGlb(glb), flatGlb)\n\n```", "```\n> data Omega = W Omega deriving (Show)\n>\n> zero, w :: Omega\n> zero = zero\n> w    = W w -- the first ordinal, aka Infinity\n\n```", "```\nw = fix W\nw = lubs (iterate W zero)\n\n```", "```\n> instance Ord Omega where\n>     max = lub\n>     min = glb\n\n```", "```\n> instance Enum Omega where\n>     succ = W\n>     pred (W x) = x -- pred 0 = 0\n>     toEnum n = iterate W zero !! n\n>\n> instance HasLub Omega where\n>     lub x y = flatLub x y `seq` W (pred x `lub` pred y)\n\n```", "```\nisZero (W _) = False -- returns ⊥ if zero (why can’t it return True?)\nlub x y = (isZero x `lub` isZero y) `seq` W (pred x `lub` pred y)\n\n```", "```\ndata Nat = Z | S Nat\n\npredNat (S x) = x\npredNat Z = Z\n\nmaxNat Z Z = Z\nmaxNat x y = S (maxNat (predNat x) (predNat y))\n\n```", "```\n> instance Eq Omega where -- needed for Num\n\n```", "```\n> instance HasGlb Omega where\n>    glb (W x') (W y') = W (x' `glb` y')\n\n```", "```\n> instance Num Omega where\n>     x + y = y `lub` add x y\n>         where add (W x') y = succ (x' + y)\n>     (W x') * y = (x' * y) + y\n>     fromInteger n = toEnum (fromIntegral n)\n\n```", "```\nnatPlus Z y = y\nnatPlus (S x') y = S (natPlus x' y)\n\nnatMul Z y = Z\nnatMul (S x') y = natPlus y (natMul x' y)\n\n```", "```\nfactorial n = W zero `lub` (n * factorial (pred n))\n\n```", "```\nf ⊥ = ⊥\nf (C x') = ...\n\n```", "```\nf (C x') = ...\n\n```", "```\ng ⊥ = c\ng (C x') = ...\n\n```", "```\ng x = c `lub` g' x\n  where g' (C x') = ...\n\n```", "```\nx + y = add x y `lub` add y x\n  where add (W x') y = succ (x' + y)\n\n```", "```\nparCommute f x y = f x y `lub` f y x\n\n```"]