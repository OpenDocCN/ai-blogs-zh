- en: <!--yml
  prefs: []
  type: TYPE_NORMAL
- en: 'category: 未分类'
  prefs: []
  type: TYPE_NORMAL
- en: 'date: 2024-07-01 18:17:06'
  prefs: []
  type: TYPE_NORMAL
- en: -->
  prefs: []
  type: TYPE_NORMAL
- en: 'Announcing cabal new-build: Nix-style local builds : ezyang’s blog'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 来源：[http://blog.ezyang.com/2016/05/announcing-cabal-new-build-nix-style-local-builds/](http://blog.ezyang.com/2016/05/announcing-cabal-new-build-nix-style-local-builds/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`cabal new-build`, also known as “Nix-style local builds”, is a new command
    inspired by Nix that comes with cabal-install 1.24\. Nix-style local builds combine
    the best of non-sandboxed and sandboxed Cabal:'
  prefs: []
  type: TYPE_NORMAL
- en: Like sandboxed Cabal today, we build sets of independent local packages deterministically
    and independent of any global state. new-build will never tell you that it can't
    build your package because it would result in a “dangerous reinstall.” Given a
    particular state of the Hackage index, your build is completely reproducible.
    For example, you no longer need to compile packages with profiling ahead of time;
    just request profiling and new-build will rebuild all its dependencies with profiling
    automatically.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Like non-sandboxed Cabal today, builds of external packages are cached globally,
    so that a package can be built once, and then reused anywhere else it is also
    used. No need to continually rebuild dependencies whenever you make a new sandbox:
    dependencies which can be shared, are shared.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Nix-style local builds work with all versions of GHC supported by cabal-install
    1.24, which currently is GHC 7.0 and later. Additionally, cabal-install is on
    a different release cycle than GHC, so we plan to be pushing bugfixes and updates
    on a faster basis than GHC's yearly release cycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although this feature is in only beta (there are bugs, see “Known Issues”,
    and the documentation is a bit sparse), I’ve been successfully using Nix-style
    local builds exclusively to do my Haskell development. It''s hard to overstate
    my enthusiasm for this new feature: it “just works”, and you don''t need to assume
    that there is a distribution of blessed, version-pegged packages to build against
    (e.g., Stackage). Eventually, `new-build` will simply replace the existing `build`
    command.'
  prefs: []
  type: TYPE_NORMAL
- en: Quick start
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Nix-style local builds “just work”: there is very little configuration that
    needs to be done to start working with it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download and install cabal-install 1.24:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure the newly installed `cabal` is in your path.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To build a single Cabal package, instead of running `cabal configure; cabal
    build`, you can use Nix-style builds by prefixing these commands with `new-`;
    e.g., `cabal new-configure; cabal new-build`. `cabal new-repl` is also supported.
    (Unfortunately, other commands are not yet supported, e.g. `new-clean` ([#2957](https://github.com/haskell/cabal/issues/2957))
    or `new-freeze` ([#2996](https://github.com/haskell/cabal/issues/2996)).)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To build multiple Cabal packages, you need to first create `cabal.project`
    file in some root directory. For example, in the Cabal repository, there is a
    root directory with a folder per package, e.g., the folders `Cabal` and `cabal-install`.
    Then in `cabal.project`, specify each folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, in the directory for a package, you can say `cabal new-build` to build
    all of the components in that package; alternately, you can specify a list of
    targets to build, e.g., `package-tests cabal` asks to build the `package-tests`
    test suite and the `cabal` executable. A component can be built from any directory;
    you don''t have to be cd''ed into the directory containing the package you want
    to build. Additionally, you can qualify targets by the package they came from,
    e.g., `Cabal:package-tests` asks specifically for the `package-tests` component
    from Cabal. There is no need to manually configure a sandbox: add a `cabal.project`
    file, and it just works!'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Unlike sandboxes, there is no need to `add-source`; just add the package directories
    to your `cabal.project`. And unlike traditional `cabal install`, there is no need
    to explicitly ask for packages to be installed; `new-build` will automatically
    fetch and build dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a convenient [script](https://github.com/hvr/multi-ghc-travis/blob/master/make_travis_yml_2.hs)
    you can use for hooking up `new-build` to your [Travis builds](https://github.com/hvr/multi-ghc-travis).
  prefs: []
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Nix-style local builds are implemented with these two big ideas:'
  prefs: []
  type: TYPE_NORMAL
- en: For external packages (from Hackage), prior to compilation, we take all of the
    inputs which would influence the compilation of a package (flags, dependency selection,
    etc.) and hash it into an identifier. Just as in Nix, these hashes uniquely identify
    the result of a build; if we compute this identifier and we find that we already
    have this ID built, we can just use the already built version. These packages
    are stored globally in `~/.cabal/store`; you can list all of the Nix packages
    that are globally available using `ghc-pkg list --package-db=$HOME/.cabal/store/ghc-VERSION/package.db`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For local packages, we instead assign an `inplace` identifier, e.g., `foo-0.1-inplace`,
    which is local to a given `cabal.project`. These packages are stored locally in
    `dist-newstyle/build`; you can list all of the per-project packages using `ghc-pkg
    list --package-db=dist-newstyle/packagedb`. This treatment applies to any remote
    packages which depend on local packages (e.g., if you vendored some dependency
    which your other dependencies depend on.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Furthermore, Nix local builds use a deterministic dependency solving strategy,
    by doing dependency solving independently of the locally installed packages. Once
    we've solved for the versions we want to use and have determined all of the flags
    that will be used during compilation, we generate identifiers and then check if
    we can improve packages we would have needed to build into ones that are already
    in the database.
  prefs: []
  type: TYPE_NORMAL
- en: Commands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`new-configure FLAGS`'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Overwrites `cabal.project.local` based on FLAGS.
  prefs: []
  type: TYPE_NORMAL
- en: '`new-build [FLAGS] [COMPONENTS]`'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Builds one or more components, automatically building any local and non-local
    dependencies (where a local dependency is one where we have an inplace source
    code directory that we may modify during development). Non-local dependencies
    which do not have a transitive dependency on a local package are installed to
    `~/.cabal/store`, while all other dependencies are installed to `dist-newstyle`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The set of local packages is read from `cabal.project`; if none is present,
    it assumes a default project consisting of all the Cabal files in the local directory
    (i.e., `packages: *.cabal`), and optional packages in every subdirectory (i.e.,
    `optional-packages: */*.cabal`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The configuration of the build of *local* packages is computed by reading flags
    from the following sources (with later sources taking priority):'
  prefs: []
  type: TYPE_NORMAL
- en: '`~/.cabal/config`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`cabal.project`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`cabal.project.local` (usually generated by `new-configure`)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`FLAGS` from the command line'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The configuration of non-local packages is only affect by package-specific flags
    in these sources; global options are not applied to the build. (For example, if
    you `--disable-optimization`, this will only apply to your local inplace packages,
    and not their remote dependencies.)
  prefs: []
  type: TYPE_NORMAL
- en: '`new-build` does not read configuration from `cabal.config`.'
  prefs: []
  type: TYPE_NORMAL
- en: Phrasebook
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here is a handy phrasebook for how to do existing Cabal commands using Nix
    local build:'
  prefs: []
  type: TYPE_NORMAL
- en: '| old-style | new-style |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `cabal configure` | `cabal new-configure` |'
  prefs: []
  type: TYPE_TB
- en: '| `cabal build` | `cabal new-build` |'
  prefs: []
  type: TYPE_TB
- en: '| `cabal clean` | `rm -rf dist-newstyle cabal.project.local` |'
  prefs: []
  type: TYPE_TB
- en: '| `cabal run EXECUTABLE` | `cabal new-build; ./dist-newstyle/build/PACKAGE-VERSION/build/EXECUTABLE/EXECUTABLE`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `cabal repl` | `cabal new-repl` |'
  prefs: []
  type: TYPE_TB
- en: '| `cabal test TEST` | `cabal new-build; ./dist-newstyle/build/PACKAGE-VERSION/build/TEST/TEST`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `cabal benchmark BENCH` | `cabal new-build; ./dist-newstyle/build/PACKAGE-VERSION/build/BENCH/BENCH`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `cabal haddock` | does not exist yet |'
  prefs: []
  type: TYPE_TB
- en: '| `cabal freeze` | does not exist yet |'
  prefs: []
  type: TYPE_TB
- en: '| `cabal install --only-dependencies` | unnecessary (handled by `new-build`)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `cabal install` | does not exist yet (for libraries `new-build` should be
    sufficient; for executables, they can be found in `~/.cabal/store/ghc-GHCVER/PACKAGE-VERSION-HASH/bin`)
    |'
  prefs: []
  type: TYPE_TB
- en: cabal.project files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`cabal.project` files actually support a variety of options beyond `packages`
    for configuring the details of your build. Here is a simple example file which
    displays some of the possibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: When you run `cabal new-configure`, it writes out a `cabal.project.local` file
    which saves any extra configuration options from the command line; if you want
    to know how a command line arguments get translated into a `cabal.project` file,
    just run `new-configure` and inspect the output.
  prefs: []
  type: TYPE_NORMAL
- en: Known issues
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As a tech preview, the code is still [a little rough around the edges](https://github.com/haskell/cabal/labels/nix-local-build).
    Here are some more major issues you might run into:'
  prefs: []
  type: TYPE_NORMAL
- en: Although dependency resolution is deterministic, if you update your Hackage
    index with `cabal update`, [dependency resolution will change too](https://github.com/haskell/cabal/issues/2996).
    There is no `cabal new-freeze`, so you'll have to manually construct the set of
    desired constraints.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A new feature of new-build is that it avoids rebuilding packages when there
    have been no changes to them, by tracking the hashes of their contents. However,
    this dependency tracking is not 100% accurate (specifically, it relies on your
    Cabal file accurately reporting all file dependencies ala `sdist`, and it doesn''t
    know about search paths). There''s currently no UI for forcing a package to be
    recompiled; however you can induce a recompilation fairly easily by removing an
    appropriate cache file: specifically, for the package named `p-1.0`, delete the
    file `dist-newstyle/build/p-1.0/cache/build`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On Mac OS X, Haskell Platform, you may get the message “Warning: The package
    list for ''hackage.haskell.org'' does not exist. Run ''cabal update'' to download
    it.” That is [issue #3392](https://github.com/haskell/cabal/issues/3392); see
    the linked ticket for workarounds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you encounter other bugs, please let us know on [Cabal's issue tracker](https://github.com/haskell/cabal/issues/new?labels=nix-local-build).
  prefs: []
  type: TYPE_NORMAL
