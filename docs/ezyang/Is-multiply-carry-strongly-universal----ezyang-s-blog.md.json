["```\n    ∀ x,y ∈ M, x != y. Pr[h(x) = h(y)] ≤ 1/n\n\n    ```", "```\n    ∀ x,y ∈ M, a,b ∈ N.\n             Pr[h(x) = a ∧ h(y) = b] ≤ 1/n²\n\n    ```", "```\n    ∀ x₁,x₂...x_k ∈ M, a₁,a₂...a_k ∈ N.\n             Pr[h(x₁) = a₁ ∧ h(x₂) = a₂ ∧ ...] ≤ 1/n^k\n\n    ```", "```\n#define MOD 2147483647\n#define HL 31\nlong hash31(long long a, long long b, long long x)\n{\n\n  long long result;\n  long lresult;\n\n  // return a hash of x using a and b mod (2^31 - 1)\n// may need to do another mod afterwards, or drop high bits\n// depending on d, number of bad guys\n// 2^31 - 1 = 2147483647\n\n  result=(a * x) + b;\n  result = ((result >> HL) + result) & MOD;\n  lresult=(long) result;\n\n  return(lresult);\n}\n\n```", "```\nTools::UniversalHash::value_type Tools::UniversalHash::hash(\n        UniversalHash::value_type x\n) const\n{\n        uint64_t r = m_a[0];\n        uint64_t xd = 1;\n\n        for (uint16_t i = 1; i < m_k; i++)\n        {\n                xd = (xd * x) % m_P;\n                r += (m_a[i] * xd) % m_P;\n                        // FIXME: multiplications here might overflow.\n        }\n\n        r = (r % m_P) & 0xFFFFFFFF;\n                // this is the same as x % 2^32\\. The modulo operation with powers\n                // of 2 (2^n) is a simple bitwise AND with 2^n - 1.\n\n        return static_cast<value_type>(r);\n}\n\n```", "```\nf1 <&> f2 = \\(r1, r2) a -> (f1 r1 a, f2 r2 a)\n\n```", "```\n(foldl xs f1 z1, foldl xs f2 z2) == foldl xs (f1 <&> f2) (z1, z2)\n\n```", "```\naverage = uncurry (/) . foldl' ((+) <&> (flip (const (+1)))) (0,0)\n\n```"]