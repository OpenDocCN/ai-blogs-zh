["```\nInductive nat : Set := (* defined in standard library *)\n  | 0 : nat\n  | S : nat -> nat.\n\ndata Nat = Z | S Nat\n\n```", "```\nInductive NatF (x : Set) : Set :=\n  | F0 : NatF x.\n  | FS : x -> NatF x.\n\ndata NatF x = FZ | FS x\n\n```", "```\nHint Constructors nat NatF.\nGoal ~ (forall (P : nat -> Prop), (NatF (forall n : nat, P n) -> forall n : nat, P n)).\n  intro H; specialize (H (fun n => False)); auto.\nQed.\n\n```", "```\n(* Check nat_ind. *)\nnat_ind : forall P : nat -> Prop,\n  P 0 -> (forall n : nat, P n -> P (S n)) -> forall n : nat, P n\n\n```", "```\nfun (P : nat -> Prop) => forall n : nat, match n with 0 => True | S n' => P n' end -> P n\n\n```", "```\nfun (P : nat -> Prop) => forall n : nat, match n with 0 => True | S n' => P n' end\n\n```", "```\nFixpoint P (n : nat) : Prop :=\n  match n with 0 => True | S n' => P n' end.\n\n```", "```\nHint Unfold P.\nGoal forall n, P n = True.\n  induction n; auto.\nQed.\n\n```"]