["```\n> module Quicksort where\n>\n> open import Data.Nat public using (ℕ; suc; zero)\n> open import Data.List public using (List; _∷_; []; _++_; [_]; length; partition)\n> open import Data.Bool public using (Bool; true; false)\n> open import Data.Product public using (_×_; _,_; proj₁; proj₂)\n\n```", "```\n> data ⊤ : Set where unit : ⊤\n\n```", "```\n> data ⊥ : Set where\n\n```", "```\ndata ℕ : Set where\n  zero : ℕ\n  suc : ℕ → ℕ\n\n```", "```\n> Rel : Set → Set₁\n> Rel A = A → A → Set\n\n```", "```\nRel A = (_ : A) → (_ : A) → (_ : Set)\n\n```", "```\n> data _<_ (m : ℕ) : ℕ → Set where\n>   <-base : m < suc m\n>   <-step : {n : ℕ} → m < n → m < suc n\n\n```", "```\n> example₁ : 3 < 5\n> example₁ = <-step <-base\n\n```", "```\n> _≮_ : Rel ℕ\n> a ≮ b = a < b → ⊥\n\n```", "```\n> example₂ : 5 ≮ 2\n> example₂ (<-step (<-step ()))\n\n```", "```\n> module WF {A : Set} (_<_ : Rel A) where\n\n```", "```\n>   data Acc (x : A) : Set where\n>     acc : (∀ y → y < x → Acc y) → Acc x\n\n```", "```\n>   Well-founded : Set\n>   Well-founded = ∀ x → Acc x\n\n```", "```\n> <-ℕ-wf : WF.Well-founded _<_\n> <-ℕ-wf x = WF.acc (aux x)\n>   where\n>     aux : ∀ x y → y < x → WF.Acc _<_ y\n>     --  : (x : _) → (∀ y → y < x → WF.Acc _<_ y)\n>     aux .(suc y) y <-base = <-ℕ-wf y\n\n```", "```\n>     aux .(suc x) y (<-step {x} y<x) = aux x y y<x\n\n```", "```\n> module Inverse-image-Well-founded { A B }\n>   -- Should actually used ≺, but I decided it looked to similar to < for comfort.\n>   (_<_ : Rel B)(f : A → B) where\n>   _⊰_ : Rel A\n>   x ⊰ y = f x < f y\n>\n>   ii-acc : ∀ {x} → WF.Acc _<_ (f x) → WF.Acc _⊰_ x\n>   ii-acc (WF.acc g) = WF.acc (λ y fy<fx → ii-acc (g (f y) fy<fx))\n\n```", "```\n>   ii-wf : WF.Well-founded _<_ → WF.Well-founded _⊰_\n>   ii-wf wf x = ii-acc (wf (f x))\n>   --    wf = λ x → ii-acc (wf (f x))\n>   -- I.e. of course the construction ii-acc will work for any x.\n\n```", "```\n> module <-on-length-Well-founded { A } where\n>   open Inverse-image-Well-founded { List A } _<_ length public\n>   wf : WF.Well-founded _⊰_\n>   wf = ii-wf <-ℕ-wf\n\n```", "```\n> s<s : ∀ {a b} → a < b → suc a < suc b\n> s<s <-base = <-base\n> s<s (<-step y) = <-step (s<s y)\n\n```", "```\n> module PartitionLemma { A } where\n>   _≼_ : Rel (List A)\n>   x ≼ y = length x < suc (length y) -- succ to let us reuse <\n\n```", "```\n>   partition-size : (p : A → Bool) (xs : List A)\n>     → proj₁ (partition p xs) ≼ xs\n>     × proj₂ (partition p xs) ≼ xs\n\n```", "```\n>   partition-size p [] = <-base , <-base\n>   partition-size p (x ∷ xs)\n>     with p x | partition p xs | partition-size p xs\n>   ... | true | as , bs | as-size , bs-size = s<s as-size , <-step bs-size\n>   ... | false | as , bs | as-size , bs-size = <-step as-size , s<s bs-size\n\n```", "```\n> module Quick {A} (p : A → A → Bool) where\n\n```", "```\n>   open <-on-length-Well-founded\n>   open PartitionLemma\n>   quicksort' : (xs : List A) → WF.Acc _⊰_ xs → List A\n>   quicksort' [] _ = []\n>   quicksort' (x ∷ xs) (WF.acc g) ::\n\n```", "```\n>     with partition (p x) xs | partition-size (p x) xs\n>   ... | small , big | small-size , big-size = small' ++ [ x ] ++ big'\n>     where\n>       small' = quicksort' small (g small small-size)\n>       big' = quicksort' big (g big big-size)\n>   quicksort : List A → List A\n>   quicksort xs = quicksort' xs (wf xs)\n\n```"]