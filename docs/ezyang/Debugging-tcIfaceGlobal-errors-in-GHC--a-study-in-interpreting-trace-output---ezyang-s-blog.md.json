["```\nghc-stage2: panic! (the 'impossible' happened)\n  (GHC version 8.1.20160512 for x86_64-unknown-linux):\n        tcIfaceGlobal (global): not found\n  You are in a maze of twisty little passages, all alike.\n  While forcing the thunk for TyThing Data\n  which was lazily initialized by initIfaceTcRn,\n  I tried to tie the knot, but I couldn't find Data\n  in the current type environment.\n  If you are developing GHC, please read Note [Tying the knot]\n  and Note [Type-checking inside the knot].\n  Consider rebuilding GHC with profiling for a better stack trace.\n  Contents of current type environment: []\n\n```", "```\n:! cp Boot1.hs Boot.hs\n:l Boot.hs\n:! sleep 1\n:! cp Boot2.hs Boot.hs\n:r\n\n```", "```\n-- Boot.hs-boot\nmodule Boot where\ndata Data\n\n-- A.hs\nmodule A where\nimport {-# SOURCE #-} Boot\nclass Class a where\n  method :: a -> Data -> a\n\n-- Boot1.hs\nmodule Boot where\ndata Data\n\n-- Boot2.hs\n{-# LANGUAGE ExistentialQuantification #-}\nmodule Boot where\nimport A\ndata Data = forall n. Class n => D n\n\n```", "```\n-- Boot.hs-boot\nmodule Boot\ndata Data\n\n-- A.hs\nmodule A\nimport {-# SOURCE #-} Boot\ntype S = Data\n\n-- Boot.hs\nmodule Boot\nimport A\nx :: S\n\n```", "```\n-- Boot.hs-boot\nmodule Boot where\ndata D\n\n-- A.hs\nmodule A where\nimport {-# SOURCE #-} Boot\nclass K a where\n  method :: a -> D -> a\n\n-- Boot.hs\n{-# LANGUAGE ExistentialQuantification #-}\nmodule Boot where\nimport A\ndata Data = forall n. K n => D n\n\n```", "```\n; case if_rec_types env of {    -- Note [Tying the knot]\n    Just (mod, get_type_env)\n        | nameIsLocalOrFrom mod name\n        -> do           -- It's defined in the module being compiled\n        { type_env <- setLclEnv () get_type_env         -- yuk\n        ; case lookupNameEnv type_env name of\n                Just thing -> return thing\n                Nothing   -> pprPanic \"tcIfaceGlobal (local): not found:\"\n                                        (ppr name $$ ppr type_env) }\n\n  ; _ -> do\n\n```", "```\n-- Note [Tying the knot]\n-- ~~~~~~~~~~~~~~~~~~~~~\n-- The if_rec_types field is used in two situations:\n--\n-- a) Compiling M.hs, which indirectly imports Foo.hi, which mentions M.T\n--    Then we look up M.T in M's type environment, which is splatted into if_rec_types\n--    after we've built M's type envt.\n--\n-- b) In ghc --make, during the upsweep, we encounter M.hs, whose interface M.hi\n--    is up to date.  So we call typecheckIface on M.hi.  This splats M.T into\n--    if_rec_types so that the (lazily typechecked) decls see all the other decls\n--\n-- In case (b) it's important to do the if_rec_types check *before* looking in the HPT\n-- Because if M.hs also has M.hs-boot, M.T will *already be* in the HPT, but in its\n-- emasculated form (e.g. lacking data constructors).\n\n```", "```\nTc2 (src)\nTc3\ntxExtendKindEnv []\ntxExtendKindEnv []\ntcTyAndCl start kind checking ()\nkcTyClGroup\n  module Boot\n    data D = forall n_anU. K n_anU => D\n<<some log elided here>>\ntc_lhs_type:\n  K n_anU\n  Constraint\ntc_infer_lhs_type: K\nlk1 K\nStarting fork { Declaration for K\nLoading decl for K\nupdating EPS_\nConsidering whether to load GHC.Prim {- SYSTEM -}\nReading interface for GHC.Prim;\n    reason: Need home interface for wired-in thing TYPE\nupdating EPS_\ntc-iface-class1 K\ntc-iface-class2 K\ntc-iface-class3 K\ntc-iface-class4 K\nbuildClass\nnewGlobalBinder A C:K <no location info>\n                C:K\nnewGlobalBinder A $tcK <no location info>\n                $tcK\nStarting fork { Class op method D -> a\nghc-stage2: panic! (the 'impossible' happened)\n<<rest of the panic message>>\n\n```", "```\ntcTyVar :: TcTyMode -> Name -> TcM (TcType, TcKind)\n-- See Note [Type checking recursive type and class declarations]\n-- in TcTyClsDecls\ntcTyVar mode name         -- Could be a tyvar, a tycon, or a datacon\n  = do { traceTc \"lk1\" (ppr name)\n       ; thing <- tcLookup name\n       ; case thing of\n           ATyVar _ tv -> return (mkTyVarTy tv, tyVarKind tv)\n\n           ATcTyCon tc_tc -> do { check_tc tc_tc\n                                ; tc <- get_loopy_tc name tc_tc\n                                ; handle_tyfams tc tc_tc }\n                             -- mkNakedTyConApp: see Note [Type-checking inside the knot]\n                 -- NB: we really should check if we're at the kind level\n                 -- and if the tycon is promotable if -XNoTypeInType is set.\n                 -- But this is a terribly large amount of work! Not worth it.\n\n           AGlobal (ATyCon tc)\n             -> do { check_tc tc\n                   ; handle_tyfams tc tc }\n\n```", "```\nStarting fork { Declaration for K\nLoading decl for K\nupdating EPS_\nConsidering whether to load GHC.Prim {- SYSTEM -}\nReading interface for GHC.Prim;\n    reason: Need home interface for wired-in thing TYPE\nupdating EPS_\ntc-iface-class1 K\ntc-iface-class2 K\ntc-iface-class3 K\ntc-iface-class4 K\nbuildClass\nnewGlobalBinder A C:K <no location info>\n                C:K\nnewGlobalBinder A $tcK <no location info>\n                $tcK\nStarting fork { Class op method D -> a\nghc-stage2: panic! (the 'impossible' happened)\n<<rest of the panic message>>\n\n```", "```\n= bindIfaceTyConBinders binders $ \\ tyvars binders' -> do\n  { tc_name <- lookupIfaceTop tc_occ\n  ; traceIf (text \"tc-iface-class1\" <+> ppr tc_occ)\n  ; ctxt <- mapM tc_sc rdr_ctxt\n  ; traceIf (text \"tc-iface-class2\" <+> ppr tc_occ)\n  ; sigs <- mapM tc_sig rdr_sigs\n  ; fds  <- mapM tc_fd rdr_fds\n  ; traceIf (text \"tc-iface-class3\" <+> ppr tc_occ)\n  ; mindef <- traverse (lookupIfaceTop . mkVarOccFS) mindef_occ\n  ; cls  <- fixM $ \\ cls -> do\n            { ats  <- mapM (tc_at cls) rdr_ats\n            ; traceIf (text \"tc-iface-class4\" <+> ppr tc_occ)\n            ; buildClass tc_name tyvars roles ctxt binders' fds ats sigs mindef tc_isrec }\n  ; return (ATyCon (classTyCon cls)) }\n\n```", "```\ntc_sig :: IfaceClassOp -> IfL TcMethInfo\ntc_sig (IfaceClassOp occ rdr_ty dm)\n  = do { op_name <- lookupIfaceTop occ\n       ; ~(op_ty, dm') <- forkM (mk_op_doc op_name rdr_ty) $\n                          do { ty <- tcIfaceType rdr_ty\n                             ; dm' <- tc_dm dm\n                             ; return (ty, dm') }\n             -- Must be done lazily for just the same reason as the\n             -- type of a data con; to avoid sucking in types that\n             -- it mentions unless it's necessary to do so\n       ; return (op_name, op_ty, dm') }\n\n```", "```\nbuildClass tycon_name tvs roles sc_theta binders\n           fds at_items sig_stuff mindef tc_isrec\n\n```", "```\n; op_items <- mapM (mk_op_item rec_clas) sig_stuff\n                -- Build the selector id and default method id\n\n```", "```\nmk_op_item :: Class -> TcMethInfo -> TcRnIf n m ClassOpItem\nmk_op_item rec_clas (op_name, _, dm_spec)\n  = do { dm_info <- case dm_spec of\n                      Nothing   -> return Nothing\n                      Just spec -> do { dm_name <- newImplicitBinder op_name mkDefaultMethodOcc\n                                      ; return (Just (dm_name, spec)) }\n       ; return (mkDictSelId op_name rec_clas, dm_info) }\n\n```", "```\n--- a/compiler/iface/TcIface.hs\n+++ b/compiler/iface/TcIface.hs\n@@ -429,20 +429,23 @@ tc_iface_decl _parent ignore_prags\n    tc_sig :: IfaceClassOp -> IfL TcMethInfo\n    tc_sig (IfaceClassOp occ rdr_ty dm)\n      = do { op_name <- lookupIfaceTop occ\n-          ; ~(op_ty, dm') <- forkM (mk_op_doc op_name rdr_ty) $\n-                             do { ty <- tcIfaceType rdr_ty\n-                                ; dm' <- tc_dm dm\n-                                ; return (ty, dm') }\n+          ; let doc = mk_op_doc op_name rdr_ty\n+          ; op_ty <- forkM (doc <+> text \"ty\") $ tcIfaceType rdr_ty\n                 -- Must be done lazily for just the same reason as the\n                 -- type of a data con; to avoid sucking in types that\n                 -- it mentions unless it's necessary to do so\n+          ; dm'   <- tc_dm doc dm\n           ; return (op_name, op_ty, dm') }\n\n-   tc_dm :: Maybe (DefMethSpec IfaceType) -> IfL (Maybe (DefMethSpec Type))\n-   tc_dm Nothing               = return Nothing\n-   tc_dm (Just VanillaDM)      = return (Just VanillaDM)\n-   tc_dm (Just (GenericDM ty)) = do { ty' <- tcIfaceType ty\n-                                    ; return (Just (GenericDM ty')) }\n+   tc_dm :: SDoc\n+         -> Maybe (DefMethSpec IfaceType)\n+         -> IfL (Maybe (DefMethSpec Type))\n+   tc_dm _   Nothing               = return Nothing\n+   tc_dm _   (Just VanillaDM)      = return (Just VanillaDM)\n+   tc_dm doc (Just (GenericDM ty))\n+        = do { -- Must be done lazily to avoid sucking in types\n+             ; ty' <- forkM (doc <+> text \"dm\") $ tcIfaceType ty\n+             ; return (Just (GenericDM ty')) }\n\n```"]