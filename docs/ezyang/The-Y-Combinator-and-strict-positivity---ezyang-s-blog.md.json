["```\nPrelude> let y = \\f -> (\\x -> f (x x)) (\\x -> f (x x))\n\n<interactive>:2:43:\n    Occurs check: cannot construct the infinite type: t1 = t1 -> t0\n    In the first argument of `x', namely `x'\n    In the first argument of `f', namely `(x x)'\n    In the expression: f (x x)\n\n```", "```\nPrelude> newtype Rec a = In { out :: Rec a -> a }\nPrelude> let y = \\f -> (\\x -> f (out x x)) (In (\\x -> f (out x x)))\nPrelude> :t y\ny :: (a -> a) -> a\n\n```", "```\nInductive Rec (A : Type) :=\n  In : (Rec A -> A) -> Rec A.\n\n(* Error: Non strictly positive occurrence of \"Rec\" in \"(Rec A -> A) -> Rec A\". *)\n\n```", "```\ndata Term = Lambda (Term -> Term)\n          | App Term Term\n\n```"]