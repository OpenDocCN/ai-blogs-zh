- en: <!--yml
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <!--yml
- en: 'category: 未分类'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 'category: 未分类'
- en: 'date: 2024-07-01 18:18:22'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 'date: 2024-07-01 18:18:22'
- en: -->
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: -->
- en: 'Inessential Guide to data-accessor : ezyang’s blog'
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: data-accessor 不太重要：ezyang 的博客
- en: 来源：[http://blog.ezyang.com/2010/04/inessential-guide-to-data-accessor/](http://blog.ezyang.com/2010/04/inessential-guide-to-data-accessor/)
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来源：[http://blog.ezyang.com/2010/04/inessential-guide-to-data-accessor/](http://blog.ezyang.com/2010/04/inessential-guide-to-data-accessor/)
- en: '[data-accessor](http://hackage.haskell.org/package/data-accessor-0.2.1.2) is
    a package that makes records *not suck.* Instead of this code:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '[data-accessor](http://hackage.haskell.org/package/data-accessor-0.2.1.2) 是一个使记录*更有用*的包。与这段代码不同：'
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can write this:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以写这样：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In particular, `(field ^= newVal)` is now a value, *not* a bit of extra syntax,
    that you can treat as a first-class citizen.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是 `(field ^= newVal)` 现在是一个值，而不是额外语法的一部分，你可以将其视为一级公民。
- en: 'I came across this module while attempting to use [Chart](http://hackage.haskell.org/package/Chart)
    (of criterion fame) to graph some data. I didn''t recognize it at first, though;
    it was only after playing around with code samples did I realize that `^=` was
    not a combinator that Chart had invented for its own use (as opposed to the potpourri
    of `-->`, `<+>`, `|||` and friends you might see in an *xmonad.hs*). When utilized
    with Template Haskell, Data.Accessor represents something of a *replacement* for
    the normal record system, and so it''s useful to know when a module speaks this
    other language. Signs that you''re in a module using Data.Accessor:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当我尝试使用[Chart](http://hackage.haskell.org/package/Chart)（以 criterion 著称）绘制一些数据时，我遇到了这个模块。起初我并没有意识到这一点，直到我尝试了一些代码示例后才意识到，`^=`
    并不是 Chart 为自己发明的一个组合子（与你可能在 *xmonad.hs* 中看到的 `-->`、`<+>`、`|||` 和其他朋友们不同）。在使用 Template
    Haskell 时，Data.Accessor 代表了普通记录系统的一种*替代*，因此了解一个模块何时使用这种其他语言是很有用的。使用 Data.Accessor
    的模块的迹象包括：
- en: Use of the `^=` operator in code samples
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在代码示例中使用 `^=` 运算符
- en: All of the records have underscores suffixed, such as `plot_lines_title_`
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有的记录都有下划线后缀，例如 `plot_lines_title_`
- en: Template Haskell gobbledygook (including type variables that look like `x[acGI]`,
    especially in the "real" accessors that Template Haskell generated).
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Template Haskell 魔法（包括看起来像 `x[acGI]` 的类型变量，尤其是 Template Haskell 生成的“真实”访问器中）。
- en: Unqualified `T` data types floating around. (As Brent Yorgey tells me, this
    is a Henning-ism in which he will define a type T or typeclass C intended to be
    used only with a qualified import, but Haddock throws away this information. You
    can use `:t` in GHC to get back this information if you're not sure.)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮动的不合格的 `T` 数据类型。 （正如 Brent Yorgey 告诉我的，这是 Henning-ism，他将定义一个类型 T 或类型类 C，只用于带有限定导入，但
    Haddock 会丢弃此信息。如果你不确定，可以在 GHC 中使用 `:t` 来获取此信息。）
- en: Once you've identified that a module is indeed using Data.Accessor, you've won
    most of the battle. Here is a whirlwind tutorial on how to use records that use
    data-accessor.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确认一个模块确实使用 Data.Accessor，你已经赢得了大部分战斗。这是一个关于如何使用使用 data-accessor 记录的快速教程。
- en: '*Interpreting types.* An *accessor* (represented by the type `Data.Accessor.T
    r a`) is defined to be a getter (`r -> a`) and setter (`a -> r -> r`). `r` is
    the type of the record, and `a` is the type of the value that can be retrieved
    or set. If Template Haskell was used to generate the definitions, polymorphic
    types inside of `a` and `r` will frequently be universally quantified with type
    variables that `x[acGI]`, don''t worry too much about them; you can pretend they''re
    normal type variables. For the curious, these are generated by the quotation monad
    in Template Haskell).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*解释类型。* 一个*访问器*（由类型 `Data.Accessor.T r a` 表示）被定义为一个获取器（`r -> a`）和设置器（`a ->
    r -> r`）。`r` 是记录的类型，`a` 是可以检索或设置的值的类型。如果使用 Template Haskell 生成定义，`a` 和 `r` 中的多态类型通常会使用看起来像
    `x[acGI]` 的类型变量普遍量化，不用太担心它们；你可以假装它们是普通的类型变量。对于好奇的人来说，这些是由 Template Haskell 中的引用单子生成的。'
- en: '*Accessing record fields.* The old way:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*访问记录字段。* 旧的方法：'
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can do things several ways with Data.Accessor:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Data.Accessor 可以有多种方式：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Setting record fields.* The old way:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*设置记录字段。* 旧的方法：'
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The new ways:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 新的方法：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Accessing and setting sub-record fields.* The old ways:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*访问和设置子记录字段。* 旧的方法：'
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The new ways (this is bit reminiscent of [semantic editor combinators](http://conal.net/blog/posts/semantic-editor-combinators/)):'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 新的方法（这有点像[语义编辑器组合子](http://conal.net/blog/posts/semantic-editor-combinators/)）：
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: There are also functions for modifying records inside the state monad, but I'll
    leave those explanations for [the Haddock documentation](http://hackage.haskell.org/packages/archive/data-accessor/0.2.1.2/doc/html/Data-Accessor.html).
    Now go forth and, erm, access your data *in style*!
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些用于修改状态单子内部记录的函数，但我会把这些解释留给[Haddock 文档](http://hackage.haskell.org/packages/archive/data-accessor/0.2.1.2/doc/html/Data-Accessor.html)。现在，继续前行，并以*时尚方式*访问你的数据！
