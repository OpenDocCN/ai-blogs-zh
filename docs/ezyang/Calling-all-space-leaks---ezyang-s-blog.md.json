["```\nimport Control.Concurrent.MVar\n\n-- http://groups.google.com/group/fa.haskell/msg/e6d1d5862ecb319b\nmain1 = do file <- getContents\n           putStrLn $ show (length $ lines file) ++ \" \" ++\n                      show (length $ words file) ++ \" \" ++\n                      show (length file)\n\n-- http://www.haskell.org/haskellwiki/Memory_leak\nmain2 = let xs = [1..1000000::Integer]\n        in print (sum xs * product xs)\n\n-- http://hackage.haskell.org/trac/ghc/ticket/4334\nleaky_lines                   :: String -> [String]\nleaky_lines \"\"                =  []\nleaky_lines s                 =  let (l, s') = break (== '\\n') s\n                                 in  l : case s' of\n                                              []      -> []\n                                              (_:s'') -> leaky_lines s''\n\n-- http://stackoverflow.com/questions/5552433/how-to-reason-about-space-complexity-in-haskell\ndata MyTree = MyNode [MyTree] | MyLeaf [Int]\n\nmakeTree :: Int -> MyTree\nmakeTree 0 = MyLeaf [0..99]\nmakeTree n = MyNode [ makeTree (n - 1)\n                  , makeTree (n - 1) ]\n\ncount2 :: MyTree -> MyTree -> Int\ncount2 r (MyNode xs) = 1 + sum (map (count2 r) xs)\ncount2 r (MyLeaf xs) = length xs\n\n-- http://stackoverflow.com/questions/2777686/how-do-i-write-a-constant-space-length-function-in-haskell\nleaky_length xs = length' xs 0\n  where length' [] n = n\n        length' (x:xs) n = length' xs (n + 1)\n\n-- http://stackoverflow.com/questions/3190098/space-leak-in-list-program\nleaky_sequence [] = [[]]\nleaky_sequence (xs:xss) = [ y:ys | y <- xs, ys <- leaky_sequence xss ]\n\n-- http://hackage.haskell.org/trac/ghc/ticket/917\ninitlast :: (()->[a]) -> ([a], a)\ninitlast xs = (init (xs ()), last (xs ()))\n\nmain8 = print $ case initlast (\\()->[0..1000000000]) of\n                 (init, last) -> (length init, last)\n\n-- http://hackage.haskell.org/trac/ghc/ticket/3944\nwaitQSem :: MVar (Int,[MVar ()]) -> IO ()\nwaitQSem sem = do\n   (avail,blocked) <- takeMVar sem\n   if avail > 0 then\n     putMVar sem (avail-1,[])\n    else do\n     b <- newEmptyMVar\n     putMVar sem (0, blocked++[b])\n     takeMVar b\n\n-- http://hackage.haskell.org/trac/ghc/ticket/2607\ndata Tree a = Tree a [Tree a] deriving Show\ndata TreeEvent = Start String\n                | Stop\n                | Leaf String\n                deriving Show\nmain10 = print . snd . build $ Start \"top\" : cycle [Leaf \"sub\"]\ntype UnconsumedEvent = TreeEvent        -- Alias for program documentation\nbuild :: [TreeEvent] -> ([UnconsumedEvent], [Tree String])\nbuild (Start str : es) =\n        let (es', subnodes) = build es\n            (spill, siblings) = build es'\n        in (spill, (Tree str subnodes : siblings))\nbuild (Leaf str : es) =\n        let (spill, siblings) = build es\n        in (spill, Tree str [] : siblings)\nbuild (Stop : es) = (es, [])\nbuild [] = ([], [])\n\n```"]